<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://blog.jfx.ac/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.jfx.ac/" rel="alternate" type="text/html" /><updated>2021-01-01T15:36:43+00:00</updated><id>https://blog.jfx.ac/feed.xml</id><title type="html">jfx Blog</title><subtitle>A blog dedicated to my rambling thoughts about tech and privacy.</subtitle><author><name>Thomas (jfx)</name><email>me@jfx.ac</email></author><entry><title type="html">How to synchronise Joplin notes to AWS S3</title><link href="https://blog.jfx.ac/syncing-joplin-notes-to-aws-s3.html" rel="alternate" type="text/html" title="How to synchronise Joplin notes to AWS S3" /><published>2021-01-01T15:00:00+00:00</published><updated>2021-01-01T15:00:00+00:00</updated><id>https://blog.jfx.ac/syncing-joplin-notes-to-aws-s3</id><content type="html" xml:base="https://blog.jfx.ac/syncing-joplin-notes-to-aws-s3.html">&lt;p&gt;AWS S3 support is currently in beta for Joplin but it seems to have all the functionality necessary and has been working very smoothly across multiple devices for me. I couldn’t find any steps when I first set it up so here’s a guide on how to set it up.&lt;/p&gt;

&lt;p&gt;The pricing for S3 &lt;a href=&quot;https://aws.amazon.com/s3/pricing/&quot;&gt;is available here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;It’s worth noting that if you’re eligible for AWS free tier you will receive 5 GB of storage for free during your first 12 months.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Make sure you have created an AWS account and added billing information before attempting to make an S3 bucket.&lt;/p&gt;

&lt;h3 id=&quot;create-your-bucket&quot;&gt;Create your bucket&lt;/h3&gt;

&lt;p&gt;Once on the AWS dashboard at the top search for “S3” and go to the S3 dashboard for your region.&lt;/p&gt;

&lt;p&gt;After that go to “Create bucket” and add a unique name for your bucket like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;my-notes&lt;/code&gt;. Make sure your region is set to your correct region. You will want to have “Block all public settings” ticked.
&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/s3-config-1.png&quot; alt=&quot;AWS settings&quot; /&gt;&lt;/p&gt;

&lt;p&gt;I would recommend turning off “Bucket Versioning” as Joplin has “Note History” built into the program which will allow you to easily recover your documents. You can turn on Bucket Versioning if you are worried about application failures with Joplin and syncing across devices, however just be careful about the added expenses. You can change this at any time.&lt;/p&gt;

&lt;p&gt;I would recommend turning on “Default encryption” for your bucket also. Even if you have end-to-end-encryption enabled in Joplin it’s always a good idea to enable it for the S3 bucket. It also doesn’t cost any extra and any processing delays will be negligible.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/s3-config-2.png&quot; alt=&quot;AWS settings 2&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;generating-credentials-for-joplin&quot;&gt;Generating credentials for Joplin&lt;/h3&gt;

&lt;p&gt;Once your bucket is created you must generate IAM credentials that have access to your bucket. Before you can do this however you must create a policy which restricts access to only your bucket.&lt;/p&gt;

&lt;h4 id=&quot;create-a-policy-for-joplin-bucket&quot;&gt;Create a policy for Joplin bucket&lt;/h4&gt;

&lt;p&gt;On the AWS dashboard search for “IAM”. You should get a screen similar to the one below. Once here click on “Customer managed policies”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/iam-menu.png&quot; alt=&quot;IAM menu&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once there click “Create policy” and complete the following steps in the “Visual editor”:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Click “Service” and select “S3”&lt;/li&gt;
  &lt;li&gt;Under Actions
    &lt;ol&gt;
      &lt;li&gt;Under “List” select “ListBucket”&lt;/li&gt;
      &lt;li&gt;Under “Read” select “GetBucketLocation” and “GetObject”&lt;/li&gt;
      &lt;li&gt;Under “Write” select “DeleteObject”, “DeleteObjectVersion” and “PutObject”&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Under Resources
    &lt;ol&gt;
      &lt;li&gt;Select “Specific” as the type of resource&lt;/li&gt;
      &lt;li&gt;Click “Add ARN” for bucket&lt;/li&gt;
      &lt;li&gt;Type in your bucket name in the “Bucket name” field and click “Add”&lt;/li&gt;
      &lt;li&gt;Click “Add ARN” for object&lt;/li&gt;
      &lt;li&gt;Type in your bucket name in the “Bucket name” field like the previous step&lt;/li&gt;
      &lt;li&gt;Tick the “Any” button under “Object name” and click “Add”&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;After adding the service and adding actions&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/policy-menu-1.png&quot; alt=&quot;Create policy 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The add ARN for bucket&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/policy-menu-2.png&quot; alt=&quot;Create policy 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The add ARN for object&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/policy-menu-3.png&quot; alt=&quot;Create policy 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once these steps are completed click “Review policy”, give it a name such as &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;joplin-my-notes-policy&lt;/code&gt; and click “Create policy”.&lt;/p&gt;

&lt;h4 id=&quot;creating-your-iam-user&quot;&gt;Creating your IAM user&lt;/h4&gt;

&lt;p&gt;Now with your policy you can finally generate credentials for your devices. I would recommend that each device should have their own set of credentials/user so you can revoke them easily and also not rely on one key.&lt;/p&gt;

&lt;p&gt;To create a user search again for “IAM” and once opened select “Users” instead this time. Click “Add user” at the top and give it a name like &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;joplin-desktop&lt;/code&gt; and tick “Programmatic access”&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/iam-user-1.png&quot; alt=&quot;IAM user 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;From here you need to add the policy you just created to your user. Click “Attach existing policies directly” at the top then click “Filter policies” and select “Customer managed”.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/iam-user-2.png&quot; alt=&quot;IAM user 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Your custom policy from before should be listed and from there you can select it and click “Next” at the bottom. From here you can click “Next”, “Review” and then “Create user”. Once the user has been created your credentials (Access key ID and Secret access key) will be listed.&lt;/p&gt;

&lt;h4 id=&quot;adding-it-to-joplin&quot;&gt;Adding it to Joplin&lt;/h4&gt;

&lt;p&gt;You should now have all the information you need for Joplin.&lt;/p&gt;

&lt;p&gt;Open Joplin and click Tools -&amp;gt; Options and open the Synchronisation tab. From here fill it out like below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/syncing-joplin-notes-to-aws-s3/joplin-sync.png&quot; alt=&quot;Joplin sync&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Now your Joplin should be syncing with your S3 bucket. After syncing you should be able to refresh your bucket and see all your Joplin files and notebooks there.&lt;/p&gt;</content><author><name>Thomas</name></author><category term="aws" /><category term="joplin" /><category term="notes" /><category term="guide" /><summary type="html">AWS S3 support is currently in beta for Joplin but it seems to have all the functionality necessary and has been working very smoothly across multiple devices for me. I couldn’t find any steps when I first set it up so here’s a guide on how to set it up.</summary></entry><entry><title type="html">Moving notes from Google Keep to Joplin</title><link href="https://blog.jfx.ac/moving-notes-from-google-keep-to-joplin.html" rel="alternate" type="text/html" title="Moving notes from Google Keep to Joplin" /><published>2020-12-31T14:23:00+00:00</published><updated>2020-12-31T14:23:00+00:00</updated><id>https://blog.jfx.ac/moving-notes-from-google-keep-to-joplin</id><content type="html" xml:base="https://blog.jfx.ac/moving-notes-from-google-keep-to-joplin.html">&lt;p&gt;As part of my new years resolution to be more privacy conscious I’ve decided to try and migrate as many of my Google services to open-source alternatives as possible. After some investigation Joplin seemed to be a suitable alternative to Google Keep, my primary notes manager. Although Google Keep is more for “sticky” notes and Joplin is more like Evernote where it is supposed to hold virtual notebooks, it seemed like a suitable alternative. I liked the in-built synchronisation and end-to-end encryption (E2EE) support and it’s nice having multiple notebooks for categorising my notes.&lt;/p&gt;

&lt;h2 id=&quot;moving-over&quot;&gt;Moving over&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Before you follow this guide note that the migration script which generates an Evernote backup of your Keep files so you can export them to Joplin is written for Python 3+ and you will need Python 3+ installed on your system.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;That’s right, you need a script to convert the Keep data you download to a format that Joplin can import (Evernotes ENEX format) so you can view your notes in Joplin.&lt;/p&gt;

&lt;p&gt;A second thing to note is that by default if a note is unnamed then it will simply be titled after the date it was first made instead of the first line or the start of the content of the note. I suppose someone could rewrite the script to detect when a date is a title and if so then rename the title after the beginning of the content… I had ~300 untitled notes that I manually sorted and deleted after importing but this process can be really time consuming.&lt;/p&gt;

&lt;h3 id=&quot;steps&quot;&gt;Steps&lt;/h3&gt;

&lt;p&gt;You need to export your notes from Google Keep, fortunately Google provide a service called “Google Takeout” which allows you to export your data many of their services (Keep included). Head over to &lt;a href=&quot;https://takeout.google.com/settings/takeout&quot;&gt;https://takeout.google.com/settings/takeout&lt;/a&gt; and you’ll get a screen that looks similar to this:&lt;/p&gt;

&lt;p&gt;You want to make sure you press “Deselect all”
&lt;img src=&quot;/assets/img/moving-notes-from-google-keep-to-joplin/takeout-1.png&quot; alt=&quot;Takeout Screen 1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Then scroll down and find “Keep” and tick it
&lt;img src=&quot;/assets/img/moving-notes-from-google-keep-to-joplin/takeout-2.png&quot; alt=&quot;Takeout Screen 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Before finally creating your export with these parameters
&lt;img src=&quot;/assets/img/moving-notes-from-google-keep-to-joplin/takeout-3.png&quot; alt=&quot;Takeout Screen 3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;You should shortly receive an email with a link to download your data. Google will make you verify your account with your password before your zip/tgz can be downloaded.&lt;/p&gt;

&lt;p&gt;Once you have downloaded and extracted your files download a copy of my modified version of the keep-to-enex script from here: &lt;a href=&quot;https://gist.github.com/itsjfx/689ae620222240911a3efae33e313b1b&quot;&gt;https://gist.github.com/itsjfx/689ae620222240911a3efae33e313b1b&lt;/a&gt;. The original version is available here &lt;a href=&quot;https://gitlab.com/charlescanato/google-keep-to-evernote-converter&quot;&gt;https://gitlab.com/charlescanato/google-keep-to-evernote-converter&lt;/a&gt; but it didn’t work for me so I added a modification that allowed it to work.&lt;/p&gt;

&lt;p&gt;Put that script in the folder before the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Keep/&lt;/code&gt; folder, which should be in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Takeout/&lt;/code&gt;. After that run the script with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;python keep-to-enex.py -o output.enex -f &quot;./Keep&quot;&lt;/code&gt; - where &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;output.enex&lt;/code&gt; will be the name of the file generated and “output” will be the name of the notebook created from your backup. Feel free to rename it to something such as “Personal.enex” instead.&lt;/p&gt;

&lt;p&gt;Now open Joplin and go File -&amp;gt; Import -&amp;gt; ENEX - Evernote Export File (as Markdown) and select your ENEX backup file you just generated.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/moving-notes-from-google-keep-to-joplin/joplin-import.png&quot; alt=&quot;Joplin Import&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once this process is complete a notebook with the same name as your backup will be created and all your notes (and images) will be imported.&lt;/p&gt;</content><author><name>Thomas</name></author><category term="privacy" /><category term="joplin" /><category term="guide" /><summary type="html">As part of my new years resolution to be more privacy conscious I’ve decided to try and migrate as many of my Google services to open-source alternatives as possible. After some investigation Joplin seemed to be a suitable alternative to Google Keep, my primary notes manager. Although Google Keep is more for “sticky” notes and Joplin is more like Evernote where it is supposed to hold virtual notebooks, it seemed like a suitable alternative. I liked the in-built synchronisation and end-to-end encryption (E2EE) support and it’s nice having multiple notebooks for categorising my notes.</summary></entry><entry><title type="html">The horrors of sending transactional email… and why you should use Postmark</title><link href="https://blog.jfx.ac/the-horrors-of-sending-transactional-email.html" rel="alternate" type="text/html" title="The horrors of sending transactional email… and why you should use Postmark" /><published>2020-12-29T07:00:00+00:00</published><updated>2020-12-29T07:00:00+00:00</updated><id>https://blog.jfx.ac/the-horrors-of-sending-transactional-email</id><content type="html" xml:base="https://blog.jfx.ac/the-horrors-of-sending-transactional-email.html">&lt;p&gt;I would like to begin this post by first stating that I have not been asked by &lt;a href=&quot;https://postmarkapp.com&quot;&gt;Postmark&lt;/a&gt; to write this article. I believe that &lt;a href=&quot;https://postmarkapp.com&quot;&gt;Postmark&lt;/a&gt; offers an excellent service and because of that they deserve my recognition.&lt;/p&gt;

&lt;p&gt;As for what transactional email is, Postmark provides a good definition on their website:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Transactional email is typically a unique, high-priority message sent to a single recipient. They are often triggered by something a user does or doesn’t do.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is different to marketing/bulk/broadcast email:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;[Broadcast email] is sent to multiple recipients at once. Things like product update announcements or terms of service notices are examples of broadcast emails.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;If a user does not receive their transactional email then this will most likely result in a bad user experience. For example if a user cannot verify their email on your website since they never receive a verification email and your website requires a users email to be verified before they can purchase a product, then that user will not be able to buy their product and as a result will most likely never attempt to use your website again due to their bad user experience. This example turned out to be a reality for me.&lt;/p&gt;

&lt;h2 id=&quot;a-story-about-my-nightmares-and-experience-sending-transactional-email&quot;&gt;A story about my nightmares and experience sending transactional email&lt;/h2&gt;

&lt;p&gt;Sending transactional email just sucks because there’s a lot that can go wrong, and using an email delivery provider which is blacklisted by major email hosting providers is another thing to add to the list. At SteamLevels we were looking for an email sending provider which could reliably send emails to our users for two cases: verification emails (when users add an email to their account), as well as to send them updates about their account status (non promotional). We never sent any spam or promotional mail and our users may only ever receive 2 emails in their lifetime for their account. Several headaches were endured before we finally settled on a provider which has proven to offer this service with great success and reliability.&lt;/p&gt;

&lt;h3 id=&quot;why-not-just-move-to-a-dedicated-ip&quot;&gt;Why not just move to a dedicated IP?&lt;/h3&gt;

&lt;p&gt;When we first started having issues with email delivery this was the first idea we had to solve the issue: if other people are ruining our reputation due to us sharing an IP with them, why not just move to our own IP? We quickly discovered that due to the low volume of emails we send (we send ~5k a month now and back then it was even less) moving to a dedicated IP would create a new set of issues. This is due to IP reputation which is a core part of email delivery, Postmark have &lt;a href=&quot;https://postmarkapp.com/blog/the-false-promises-of-dedicated-ips&quot;&gt;a good blog post&lt;/a&gt; on the subject where they discuss dedicated IPs better than I could. Because of the low volume of emails we send, we were forced to continue looking for an email provider which had reputable shared IPs.&lt;/p&gt;

&lt;h3 id=&quot;mailgun&quot;&gt;Mailgun&lt;/h3&gt;

&lt;p&gt;We began by using &lt;a href=&quot;https://www.mailgun.com&quot;&gt;Mailgun&lt;/a&gt; for sending our transaction email (whom promote themselves as a “Transactional Email API Service For Developers”). We quickly discovered that Yahoo and AOL blacklisted Mailgun and as a result none of our customers with a Yahoo or AOL email could receive any of our verification emails. This was extremely problematic as it resulted in us losing customers as it turns out people still use Yahoo and AOL for their email hosting. Yahoo/AOL and Mailgun seem to have a hateful relationship that even &lt;a href=&quot;https://www.mailgun.com/blog/yahoo-aol-throttling-mailgun-festivus-airing-grievances-part-two/&quot;&gt;Mailgun wrote a blog post about it&lt;/a&gt;. None of the suggestions in the post deemed useful as we rarely sent emails to these providers and they still blacklisted us, so it was off to another provider for us.&lt;/p&gt;

&lt;h3 id=&quot;sendgrid&quot;&gt;SendGrid&lt;/h3&gt;

&lt;p&gt;This was when we went to &lt;a href=&quot;https://sendgrid.com&quot;&gt;SendGrid&lt;/a&gt;. Everyone loves to talk about how great this provider is so we decided to give it a shot. We noticed we were able to send emails to all major email providers (Gmail, Sendgrid and Outlook) which was a call for celebration, yay… but not for long. It wasn’t long before we noticed that only ~93% of our emails were being sent to our users. With further investigation we discovered yet again that our users email providers were blacklisting our SendGrid IPs due to spam being sent from them from other customers. A German postmaster we contacted explained that&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Your provider has added you to a pool of senders that regularly sends spam to our customers and to our own spamtrap addresses.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;At this point we were not happy with SendGrid and after some back and forth with their support team they informed us they are unable to move their customers to other shared IP pools manually as it gives the impression of “snowshoe spamming” and that they recommended us paying for a dedicated IP (an extra $75 a month). Actually the support staff said that they would “normally not recommend” having a dedicated IP but it would be the most “decisive way” to fix the issue. They also recommended us to go around emailing each postmaster to whitelist our domain. We were not pleased with their support as buying a dedicated IP would cause more problems due to the low amount of email we send so we decided to look again for another provider.&lt;/p&gt;

&lt;h3 id=&quot;postmark-a-new-hope&quot;&gt;Postmark, a new hope&lt;/h3&gt;

&lt;p&gt;We finally discovered &lt;a href=&quot;https://postmarkapp.com&quot;&gt;Postmark&lt;/a&gt; after finding their &lt;a href=&quot;https://postmarkapp.com/why&quot;&gt;Why Postmark?&lt;/a&gt; page on Google which got our attention. We decided to try it and at this point I was tired of transferring email templates across providers and rewriting code to use a new API, but just like Goldilocks the third time was the charm.&lt;/p&gt;

&lt;p&gt;Before being allowed to use Postmark we had to fill out a form describing our reasons for using their service and we were manually approved very quickly. This is so their service is only used for transactional email, and so they can maintain their high reliability and deliverability rates. They have wonderful support and offer to talk to you face to face when you first sign up in order to make sure you are getting the best service possible. They also send weekly digests about your deliverability so you can keep track of whether or not you’re having any issues with your email service. On top of this, they offer a &lt;a href=&quot;https://dmarc.postmarkapp.com&quot;&gt;free DMARC monitoring service&lt;/a&gt; which provides a human-readable summary of your DMARC reports. Postmark also provide &lt;a href=&quot;https://postmarkapp.com/dedicated-ips&quot;&gt;dedicated IPs&lt;/a&gt; for an extra $50 per IP per month, and offer automated warmup of these dedicated IPs to ensure your IP reputation is up to scratch. More information on their dedicated IP offerings is &lt;a href=&quot;https://postmarkapp.com/dedicated-ips&quot;&gt;available here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Enough with the sales pitch and back to our experience using them. Over 3 months worth of emails (~12k emails) only 7 emails were flagged as SPAM (all to a Russian email host). We had a bounce rate of 1.8% which is mostly due to mailboxes not existing (user typos) or mailboxes being overquota. It’s safe to say that with these rates we are very pleased with Postmark and will not be going anywhere.&lt;/p&gt;

&lt;h3 id=&quot;other-providers&quot;&gt;Other providers&lt;/h3&gt;

&lt;p&gt;That being said there are other email providers out there which could offer a better service depending on your needs. If your application uses Amazon Web Services (AWS) it may be worth looking into Amazon’s &lt;a href=&quot;https://aws.amazon.com/ses&quot;&gt;Simple Email Service (SES)&lt;/a&gt;. This is because if you’re send your email through SES with an application hosted on an Amazon EC2 it will cost you $0 for the first 62,000 emails you send each month. More information on their pricing is &lt;a href=&quot;https://aws.amazon.com/ses/pricing&quot;&gt;available here&lt;/a&gt;. They also have a cheap rate for dedicated IPs ($24.95) and you can easily tie Amazon’s SES with their &lt;a href=&quot;https://aws.amazon.com/sns&quot;&gt;Simple Notification Service (SNS)&lt;/a&gt;, &lt;a href=&quot;https://aws.amazon.com/lambda&quot;&gt;Lambda&lt;/a&gt; or any other AWS services.&lt;/p&gt;

&lt;h2 id=&quot;marketingbulk-email&quot;&gt;Marketing/Bulk email&lt;/h2&gt;

&lt;p&gt;I personally haven’t had to send any marketing or bulk email, but Postmark is now offering “broadcast messages” (bulk emailing) through their “message streams” service. More information is &lt;a href=&quot;https://postmarkapp.com/message-streams&quot;&gt;available here&lt;/a&gt;. Since Postmark is so good at sending transactional email then I have high hopes for their bulk/broadcast email service too, and would encourage anyone eager to send marketing email to investigate.&lt;/p&gt;

&lt;p&gt;Otherwise due to Amazon’s flexible pricing system and cheap dedicated IP offerings it may be worth considering SES as you can pay per email sent and because of this you can be more flexible with your email budget.&lt;/p&gt;

&lt;p&gt;I have also heard good things about &lt;a href=&quot;https://mailchimp.com&quot;&gt;Mailchimp&lt;/a&gt;, Postmark also previously recommended them for sending bulk emails.&lt;/p&gt;

&lt;p&gt;Due to my previous experiences with SendGrid and Mailgun I would not recommend them to anyone, perhaps SendGrid for bulk emails but be wary of your delivery rates with their service.&lt;/p&gt;

&lt;h2 id=&quot;materials&quot;&gt;Materials&lt;/h2&gt;

&lt;p&gt;If you’re interested in learning more about email reputation &lt;a href=&quot;https://www.mailjet.com/blog/news/sender-score-and-email-reputation&quot;&gt;Mailjet has a good article on the subject&lt;/a&gt;.&lt;/p&gt;</content><author><name>Thomas</name></author><category term="email" /><summary type="html">I would like to begin this post by first stating that I have not been asked by Postmark to write this article. I believe that Postmark offers an excellent service and because of that they deserve my recognition. As for what transactional email is, Postmark provides a good definition on their website: Transactional email is typically a unique, high-priority message sent to a single recipient. They are often triggered by something a user does or doesn’t do. This is different to marketing/bulk/broadcast email: [Broadcast email] is sent to multiple recipients at once. Things like product update announcements or terms of service notices are examples of broadcast emails. If a user does not receive their transactional email then this will most likely result in a bad user experience. For example if a user cannot verify their email on your website since they never receive a verification email and your website requires a users email to be verified before they can purchase a product, then that user will not be able to buy their product and as a result will most likely never attempt to use your website again due to their bad user experience. This example turned out to be a reality for me. A story about my nightmares and experience sending transactional email Sending transactional email just sucks because there’s a lot that can go wrong, and using an email delivery provider which is blacklisted by major email hosting providers is another thing to add to the list. At SteamLevels we were looking for an email sending provider which could reliably send emails to our users for two cases: verification emails (when users add an email to their account), as well as to send them updates about their account status (non promotional). We never sent any spam or promotional mail and our users may only ever receive 2 emails in their lifetime for their account. Several headaches were endured before we finally settled on a provider which has proven to offer this service with great success and reliability. Why not just move to a dedicated IP? When we first started having issues with email delivery this was the first idea we had to solve the issue: if other people are ruining our reputation due to us sharing an IP with them, why not just move to our own IP? We quickly discovered that due to the low volume of emails we send (we send ~5k a month now and back then it was even less) moving to a dedicated IP would create a new set of issues. This is due to IP reputation which is a core part of email delivery, Postmark have a good blog post on the subject where they discuss dedicated IPs better than I could. Because of the low volume of emails we send, we were forced to continue looking for an email provider which had reputable shared IPs. Mailgun We began by using Mailgun for sending our transaction email (whom promote themselves as a “Transactional Email API Service For Developers”). We quickly discovered that Yahoo and AOL blacklisted Mailgun and as a result none of our customers with a Yahoo or AOL email could receive any of our verification emails. This was extremely problematic as it resulted in us losing customers as it turns out people still use Yahoo and AOL for their email hosting. Yahoo/AOL and Mailgun seem to have a hateful relationship that even Mailgun wrote a blog post about it. None of the suggestions in the post deemed useful as we rarely sent emails to these providers and they still blacklisted us, so it was off to another provider for us. SendGrid This was when we went to SendGrid. Everyone loves to talk about how great this provider is so we decided to give it a shot. We noticed we were able to send emails to all major email providers (Gmail, Sendgrid and Outlook) which was a call for celebration, yay… but not for long. It wasn’t long before we noticed that only ~93% of our emails were being sent to our users. With further investigation we discovered yet again that our users email providers were blacklisting our SendGrid IPs due to spam being sent from them from other customers. A German postmaster we contacted explained that Your provider has added you to a pool of senders that regularly sends spam to our customers and to our own spamtrap addresses. At this point we were not happy with SendGrid and after some back and forth with their support team they informed us they are unable to move their customers to other shared IP pools manually as it gives the impression of “snowshoe spamming” and that they recommended us paying for a dedicated IP (an extra $75 a month). Actually the support staff said that they would “normally not recommend” having a dedicated IP but it would be the most “decisive way” to fix the issue. They also recommended us to go around emailing each postmaster to whitelist our domain. We were not pleased with their support as buying a dedicated IP would cause more problems due to the low amount of email we send so we decided to look again for another provider. Postmark, a new hope We finally discovered Postmark after finding their Why Postmark? page on Google which got our attention. We decided to try it and at this point I was tired of transferring email templates across providers and rewriting code to use a new API, but just like Goldilocks the third time was the charm. Before being allowed to use Postmark we had to fill out a form describing our reasons for using their service and we were manually approved very quickly. This is so their service is only used for transactional email, and so they can maintain their high reliability and deliverability rates. They have wonderful support and offer to talk to you face to face when you first sign up in order to make sure you are getting the best service possible. They also send weekly digests about your deliverability so you can keep track of whether or not you’re having any issues with your email service. On top of this, they offer a free DMARC monitoring service which provides a human-readable summary of your DMARC reports. Postmark also provide dedicated IPs for an extra $50 per IP per month, and offer automated warmup of these dedicated IPs to ensure your IP reputation is up to scratch. More information on their dedicated IP offerings is available here. Enough with the sales pitch and back to our experience using them. Over 3 months worth of emails (~12k emails) only 7 emails were flagged as SPAM (all to a Russian email host). We had a bounce rate of 1.8% which is mostly due to mailboxes not existing (user typos) or mailboxes being overquota. It’s safe to say that with these rates we are very pleased with Postmark and will not be going anywhere. Other providers That being said there are other email providers out there which could offer a better service depending on your needs. If your application uses Amazon Web Services (AWS) it may be worth looking into Amazon’s Simple Email Service (SES). This is because if you’re send your email through SES with an application hosted on an Amazon EC2 it will cost you $0 for the first 62,000 emails you send each month. More information on their pricing is available here. They also have a cheap rate for dedicated IPs ($24.95) and you can easily tie Amazon’s SES with their Simple Notification Service (SNS), Lambda or any other AWS services. Marketing/Bulk email I personally haven’t had to send any marketing or bulk email, but Postmark is now offering “broadcast messages” (bulk emailing) through their “message streams” service. More information is available here. Since Postmark is so good at sending transactional email then I have high hopes for their bulk/broadcast email service too, and would encourage anyone eager to send marketing email to investigate. Otherwise due to Amazon’s flexible pricing system and cheap dedicated IP offerings it may be worth considering SES as you can pay per email sent and because of this you can be more flexible with your email budget. I have also heard good things about Mailchimp, Postmark also previously recommended them for sending bulk emails. Due to my previous experiences with SendGrid and Mailgun I would not recommend them to anyone, perhaps SendGrid for bulk emails but be wary of your delivery rates with their service. Materials If you’re interested in learning more about email reputation Mailjet has a good article on the subject.</summary></entry><entry><title type="html">How to secure your nginx + Cloudflare configuration to stop any origin leaks</title><link href="https://blog.jfx.ac/securing-nginx-origin-with-cloudflare.html" rel="alternate" type="text/html" title="How to secure your nginx + Cloudflare configuration to stop any origin leaks" /><published>2020-08-03T04:42:00+00:00</published><updated>2020-08-03T04:42:00+00:00</updated><id>https://blog.jfx.ac/securing-nginx-origin-with-cloudflare</id><content type="html" xml:base="https://blog.jfx.ac/securing-nginx-origin-with-cloudflare.html">&lt;p&gt;I decided to write this as although a lot of guides on the internet provide a solid configuration for an nginx server, most of these guides will result in an IP leak somewhere under their configuration for the origin server somewhere.&lt;/p&gt;

&lt;p&gt;So you got your nginx server setup (hopefully) and it’s serving your files (or being an effective reverse proxy), but maybe you’ve noticed loading static content (images, media, etc) load slowly… or maybe you realised that anyone can get the IP address of your website and therefore the box which is hosting it, and that creeps you out a bit. Or maybe your website doesn’t have that padlock everyone else’s has and it’s “not secure”. Luckily all these issues can be solved by Cloudflare! Or maybe your website is going through Cloudflare but sometimes you notice your origin server is still publicly displaying the website, and you want to stop this leak.&lt;/p&gt;

&lt;p&gt;Unfortunately setting up Cloudflare for your website may seem simple, but setting it up securely and correctly to the inexperienced can be a difficult task. Although you may think your website is not leaking your origin IP address, it’s certainly possible that it is. This article will demonstrate how to secure your website through Cloudflare, and provide sample configurations to a hybrid nginx server which can be secure whether some vhosts are utilising Cloudflare and others aren’t (non-Cloudflare).&lt;/p&gt;

&lt;p&gt;This is not a complete guide on how to setup nginx for speed or anything like that, please just rely on this for securing your vhosts and origin server.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;This guide assumes you’re using the mainline version of nginx which will mean your sites are located in &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/nginx/conf.d/&lt;/code&gt; and your nginx user is &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nginx&lt;/code&gt;&lt;/strong&gt;. To install the mainline version of nginx &lt;a href=&quot;https://www.nginx.com/blog/nginx-1-6-1-7-released/&quot;&gt;which is recommended by the nginx team&lt;/a&gt; follow &lt;a href=&quot;https://www.techrepublic.com/article/how-to-install-the-latest-version-of-nginx-on-ubuntu-server-18-04/&quot;&gt;this guide here&lt;/a&gt; - just remember &lt;strong&gt;this guide will not work with any version of Ubuntu except for 18.04 UNLESS&lt;/strong&gt; you set the release name from &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bionic&lt;/code&gt; to your release name which you can find on Google. Maybe I’ll write my own guide :)&lt;/p&gt;

&lt;h2 id=&quot;guide&quot;&gt;Guide&lt;/h2&gt;

&lt;h1 id=&quot;step-1---generating-a-self-signed-ssl-certificate-for-your-default-server&quot;&gt;Step 1 - Generating a self-signed SSL certificate for your default server&lt;/h1&gt;

&lt;h3 id=&quot;why-this-is-necessary&quot;&gt;Why this is necessary&lt;/h3&gt;

&lt;p&gt;This is a step that many guides on the internet do not do and instead they ask you to get a Cloudflare Origin TLS certificate for all your sites. While this is good practice because you can use Full (Strict) mode for your SSL on Cloudflare, it’s not good to implement if you wish to conceal the identity of your origin server.&lt;/p&gt;

&lt;p&gt;The reason why is because of this screenshot below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cloudflare-cert-leak.png&quot; alt=&quot;Cloudflare Certificate Leak&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As you can see although no content is sent, the origin address of the website is exposed by the certificate being sent to the user. A simple web scraper could check the DNS of the certificate and easily expose the origin servers IP address.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This is a Cloudflare and nginx website I setup where the default_server block will send a Cloudflare Origin TLS Certificate and required Authenticated Origin Pulls. Don’t worry if you don’t have these setup, these are the next steps in the guide (Authenticated Origin Pulls). For reference this was following the DigitalOcean nginx+Cloudflare guide&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;generating-your-certificate&quot;&gt;Generating your certificate&lt;/h3&gt;

&lt;p&gt;Well that’s out of the way, here’s how to generate it. You will need to make sure you have openssl installed on your system.&lt;/p&gt;

&lt;p&gt;This will generate a public and private certificate that will last for 15 years. Feel free to extend it.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo openssl req -x509 -nodes -days 5475 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.pem -out /etc/ssl/certs/nginx-selfsigned.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It will ask you for some values, just keep them as the default and maybe change your country name if desired. We will use this later in our nginx setup.&lt;/p&gt;

&lt;h1 id=&quot;step-2---adding-the-self-signed-certificate-to-nginx&quot;&gt;Step 2 - Adding the Self Signed Certificate to nginx&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;For this guide I’m assuming your nginx configurations are stored in /etc/nginx/conf.d/ mainline branch, otherwise you can follow along with /etc/nginx/sites-available/&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Nginx will give us a default server file which will give you the following output once viewing your website:&lt;/p&gt;

&lt;p&gt;This file (default.conf) can be rewritten to default.old (if in conf.d) - or removed from your sites-enabled folder, and should be replaced with this new file:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sudo nano /etc/nginx/conf.d/default.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name _;
	return 403;
}

server {
	# SSL configuration
	listen 443 ssl http2 default_server;
	listen [::]:443 ssl http2 default_server;
	ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem;
	ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem;
	server_name _;
	return 403;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then type &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo nginx -t&lt;/code&gt; to make sure your configuration is correct before typing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo systemctl restart nginx&lt;/code&gt; to restart nginx to respond to the configuration change.&lt;/p&gt;

&lt;p&gt;This provides us with a base setup. If a request comes to the origin server and it does not have a server block it will come back as 403. Try test it out by going to the IP address of your box on http:// and https://&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/403-shown.png&quot; alt=&quot;403 Shown&quot; /&gt;&lt;/p&gt;

&lt;h1 id=&quot;step-3---configuring-a-host&quot;&gt;Step 3 - Configuring a host&lt;/h1&gt;

&lt;p&gt;After this we can actually configure a host we would like to route properly through Cloudflare and nginx (yay)! aka something that isn’t our default_server.
For the sake of this tutorial I’ve made a &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/www/&lt;/code&gt; folder and have my nginx pointed to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/var/www/test/&lt;/code&gt; - the config is below.
If you want to follow along, make sure you run these commands.&lt;/p&gt;

&lt;h3 id=&quot;31---making-a-test-host-skippable-if-you-have-content-already&quot;&gt;3.1 - Making a test host (skippable if you have content already)&lt;/h3&gt;

&lt;p&gt;This little micro step is skippable if you have a host working already serving content. If you wish to &lt;a href=&quot;#32---host-config&quot;&gt;skip click here to 3.2.&lt;/a&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir -p /var/www/test/
sudo chown -R nginx:nginx /var/www/
sudo find /var/www -type f -exec chmod 664 {} \;
sudo find /var/www -type d -exec chmod 775 {} \;
sudo find /var/www -type d -exec chmod g+s {} \;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;I actually copied most of these perms from &lt;a href=&quot;https://gist.github.com/stefanbc/9956ed211cd32571e73f&quot;&gt;this guide&lt;/a&gt;.
Essentially:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;changes the owner of /var/www to nginx and anyone in the nginx group.&lt;/li&gt;
  &lt;li&gt;adds 644 permissions (-rw-rw-r–) to all files in /var/www.&lt;/li&gt;
  &lt;li&gt;adds 775 permissions (drwxrwxr-x) to all directories in /var/www.&lt;/li&gt;
  &lt;li&gt;sets the SGID bit on /var/www and all directories therein; This means that all new files and subdirectories created within the current directory inherit the group ID of the directory, rather than the primary group ID of the user who created the file. This will also be passed on to new subdirectories created in the current directory.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Reminder if your nginx user is www-data the chown command should have www-data:www-data instead of nginx:nginx&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Make sure your user is in the nginx (or www-data) group, by typing &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;groups USERNAME&lt;/code&gt;. If you cannot see the group listed, run:&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo usermod -aG nginx USERNAME
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;and restart your shell.&lt;/p&gt;

&lt;p&gt;This will make the required folders and give nginx ownership of them. Essentially we are setting up our /var/www/ environment to be able to serve a website.&lt;/p&gt;

&lt;h3 id=&quot;32---host-config&quot;&gt;3.2 - Host Config&lt;/h3&gt;

&lt;p&gt;Below is a sample of a nginx config that will simply display the static content of the website. If you have an existing host make sure you have any missing fields (namely the SSL certificate ones) - and the include file.&lt;/p&gt;

&lt;p&gt;Below is a few optimisations we can add to nginx to increase speed but also increase its security.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Using a custom resolver &lt;a href=&quot;1.1.1.1&quot;&gt;Cloudflare’s DNS server&lt;/a&gt; will result in increased speed for any DNS queries your server runs.&lt;/li&gt;
  &lt;li&gt;gzip compression will mean static content will be served faster.&lt;/li&gt;
  &lt;li&gt;The SSL protocols changes will ensure only &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TLS 1.2 and TLS 1.3&lt;/code&gt; are used between your site and your visitors (Cloudflare in this case) - resulting in a secure transport.&lt;/li&gt;
  &lt;li&gt;The SSL ciphers listed are more safe and secure than the defaults and aid performance, which will help secure the communication between Cloudflare and your server.&lt;/li&gt;
  &lt;li&gt;The dhparam setting will need an additional command to get working, but essentially it allows nginx to use pre-calculated field primes and generator values to reduce resource heavy calculations on your host.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You will need to make an includes folder &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo mkdir /etc/nginx/includes&lt;/code&gt; then run this command to generate dhparams &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo openssl dhparam -out /etc/nginx/includes/dhparam.pem 4096&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Then add this conf file:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sudo nano /etc/nginx/includes/common_opts.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;resolver 1.1.1.1 1.0.0.1 valid=300s;
resolver_timeout 10s;
gzip on;
gzip_vary on;
gzip_min_length 1000;
gzip_proxied any;
gzip_comp_level 6;
gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml;
gzip_disable &quot;MSIE [1-6]\.&quot;;
ssl_prefer_server_ciphers on;
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';
# use a dhparam
ssl_dhparam /etc/nginx/includes/dhparam.pem;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here’s our base configuration file, make sure we import the conf file from the includes folder above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sudo nano /etc/nginx/conf.d/test.conf&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
	# SSL configuration
	listen 443 ssl http2;
	listen [::]:443 ssl http2;
	ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem;
	ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem;
	include /etc/nginx/includes/common_opts.conf;
	server_name testing.jfx.ac;

	location /  {
		root /var/www/test
		index index.html;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As you can see the config has no HTTP support, this is because Cloudflare can do automatic HTTPS rewrites, so why bother. Feel free to add this block in if you wish to have this functionality though.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
	listen 80;
	listen [::]:80;

	server_name testing.jfx.ac;
	return 302 https://$server_name$request_uri;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Here is a friendly Hello World for HTML so we know it’s working :)&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;nano /var/www/test/index.html&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;html&amp;gt;
Hello World!
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And this will display our testing page when we go to our site, yay!&lt;/p&gt;

&lt;h1 id=&quot;step-4---securing-your-hosts-so-only-cloudflare-can-access-them&quot;&gt;Step 4 - Securing your hosts so only Cloudflare can access them&lt;/h1&gt;

&lt;h3 id=&quot;why&quot;&gt;Why&lt;/h3&gt;

&lt;p&gt;As for why this is important, we can see that it appears the site is only serving the data if the user is going to the correct domain &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;https://testing.jfx.ac&lt;/code&gt; - no way the origin can be exposed right? This is wrong. With a simple curl command it is easy to bypass the load balancer by spoofing our &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Host&lt;/code&gt; header.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jfx@PC:~$ curl --insecure --header 'Host: testing.jfx.ac' 'https://167.172.213.53/'
&amp;lt;html&amp;gt;
Hello World!
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Scary stuff, what if someone was going through IP ranges and found our origin server this way? There’s actually a few ways to stop this, but the easiest way to stop this is to implement Authenticated Origin Pulls! More information is &lt;a href=&quot;https://blog.cloudflare.com/protecting-the-origin-with-tls-authenticated-origin-pulls&quot;&gt;here from Cloudflare themselves&lt;/a&gt;. You can also block all HTTP/HTTPS traffic to your box unless it’s from Cloudflare using a firewall (such as UFW), this step is also explained but there are pros and cons for this which are listed below.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Method&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;Pros&lt;/th&gt;
      &lt;th&gt;Cons&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;#41---adding-authenticated-origin-pulls-easy&quot;&gt;Authenticated Origin Pulls&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;ul&gt;&lt;li&gt;Easier to setup&lt;/li&gt;&lt;li&gt;Can use nginx for non Cloudflare hosts&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
      &lt;td&gt;&lt;ul&gt;&lt;li&gt;If your site is only using Cloudflare you just have an exposed web server with no purpose&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;a href=&quot;#42---blocking-all-httphttps-traffic-except-for-cloudflare-safest&quot;&gt;Firewall Blocking&lt;/a&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;ul&gt;&lt;li&gt;Safest&lt;/li&gt;&lt;li&gt;Bulletproof, no way for anyone except Cloudflare to access your web server&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
      &lt;td&gt;&lt;ul&gt;&lt;li&gt;Requires a firewall (like ufw) and a cronjob, slightly complicated setup&lt;/li&gt;&lt;li&gt;For Cloudflare only. Firewall will drop requests to nginx unless they are from Cloudflare&lt;/li&gt;&lt;/ul&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;41---adding-authenticated-origin-pulls-easy&quot;&gt;4.1 - Adding Authenticated Origin Pulls (easy)&lt;/h3&gt;

&lt;p&gt;Firstly, make sure this feature is enabled on Cloudflare or the following steps will break your site. To enable it, go to Cloudflare and go to &lt;strong&gt;SSL/TLS -&amp;gt; Origin Server -&amp;gt; ON for Authenticated Origin Pulls&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/authenticated-origin-pulls-on.png&quot; alt=&quot;Cloudflare Authenticated Origin Pulls On&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Next to setup Authenticated Origin Pulls on nginx, &lt;a href=&quot;https://support.cloudflare.com/hc/en-us/articles/204899617&quot;&gt;go here&lt;/a&gt; and at the bottom of the page download the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;origin-pull-ca.pem&lt;/code&gt; file. Once downloaded, copy its contents and output it to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/ssl/certs/cloudflare-origin.pem&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sudo nano /etc/ssl/certs/cloudflare-origin.pem&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;*contents of origin-pull-ca.pem*
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once that’s done, go back to your nginx config and add this to your &lt;strong&gt;SSL server block.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sudo nano /etc/nginx/conf.d/test.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem;
ssl_verify_client on;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It should look like this&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
	# SSL configuration
	listen 443 ssl http2;
	listen [::]:443 ssl http2;
	ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem;
	ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem;
	ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem;
	ssl_verify_client on;
	include /etc/nginx/includes/common_opts.conf;
	server_name testing.jfx.ac;

	location /  {
		root /var/www/test
		index index.html;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;em&gt;A note: you do not need to use Cloudflare’s generated SSL certificates if you wish to use Authenticated Origin Pulls.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Don’t forget to run &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo nginx -t&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo systemctl restart nginx&lt;/code&gt; to reload your config!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If we go to our website, we won’t notice a difference, but let’s try this curl spoof again:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jfx@PC:~$ curl --insecure --header 'Host: testing.jfx.ac' 'https://167.172.213.53/'
&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;&amp;lt;title&amp;gt;400 No required SSL certificate was sent&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;400 Bad Request&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt;
&amp;lt;center&amp;gt;No required SSL certificate was sent&amp;lt;/center&amp;gt;
&amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.19.1&amp;lt;/center&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Mad stuff, now we have protected our site from people trying to grab our origin IP address!&lt;/p&gt;

&lt;p&gt;There is a catch though, a 400 will return on any page where something is trying to spoof, but a 403 will return on the IP without a Host header. This gives away the fact that we are trying to be safe and only accept Cloudflare’s requests. A solution to this problem is simply adding the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssl_client_certificate&lt;/code&gt; and &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ssl_verify_client&lt;/code&gt; from above also to default.conf. With these, the error being returned will be consistent with that as the one shown above. To do this, edit default.conf and add those two lines in so it looks like this:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sudo nano /etc/nginx/conf.d/default.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name _;
	return 403;
}

server {
	# SSL configuration
	listen 443 ssl http2 default_server;
	listen [::]:443 ssl http2 default_server;
	ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem;
	ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem;
	ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem;
	ssl_verify_client on;
	server_name _;
	return 403;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With this there will be no way to determine whether or not the web server is trying to hide itself with a client certificate under a specific host.&lt;/p&gt;

&lt;h3 id=&quot;42---blocking-all-httphttps-traffic-except-for-cloudflare-safest&quot;&gt;4.2 - Blocking all HTTP/HTTPS traffic except for Cloudflare (safest)&lt;/h3&gt;

&lt;p&gt;It is possible using iptables or ufw to block all web traffic coming to your server unless it’s from Cloudflare. Personally I think for a production environment this is the most safe and most bulletproof approach, as if you expect all your web traffic to come out of Cloudflare - there’s no benefit from having a public facing web server. From a security standpoint this is also the most effective. Whilst also enforcing the technique above (Authenticated Origin Pulls) you can add more security if you’re paranoid like me.&lt;/p&gt;

&lt;p&gt;The issue with this if you wish to have a host not go through Cloudflare, then this will not be possible (unless you whitelist visitors IPs).&lt;/p&gt;

&lt;h3 id=&quot;how-to&quot;&gt;How to&lt;/h3&gt;

&lt;p&gt;I have a &lt;a href=&quot;https://github.com/itsjfx/cloudflare-nginx-ips&quot;&gt;handy script located here&lt;/a&gt; which will grab &lt;a href=&quot;https://www.cloudflare.com/ips&quot;&gt;Cloudflare’s IP range list&lt;/a&gt; and output a file for use with the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_realip_module.html&quot;&gt;Real IPs nginx module&lt;/a&gt;. This script can also optionally add UFW rules for allowing Cloudflare IPs for https and http. If your UFW is set to block all incoming, then this will only allow incoming requests on ports 80 and 443 to Cloudflare IPs. I’m not going to write up how to setup UFW, there’s a &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-20-04&quot;&gt;nice DigitalOcean tutorial here&lt;/a&gt;. Just a word of caution: &lt;strong&gt;make sure you’ve disabled any existing HTTP/HTTPS rules before relying on this script.&lt;/strong&gt; In the scripts README it tells you how to run it as a cron job so you stay on top of any updates to the Cloudflare IP range.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Make sure you run the script as root and edit the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UFW_RULES=false&lt;/code&gt; line to &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UFW_RULES=true&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;discussion&quot;&gt;Discussion&lt;/h2&gt;

&lt;p&gt;I’m going to break the discussion into two sections:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Common issues you may have with a Cloudflare setup and how to resolve them&lt;/li&gt;
  &lt;li&gt;Even tougher security methods than shown above (but are worth looking at!)&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;common-issues&quot;&gt;Common issues&lt;/h1&gt;

&lt;h3 id=&quot;nginx-not-displaying-real-ips-for-any-visitor&quot;&gt;nginx not displaying Real IPs for any visitor!&lt;/h3&gt;

&lt;p&gt;I have a &lt;a href=&quot;https://github.com/itsjfx/cloudflare-nginx-ips&quot;&gt;handy script located here&lt;/a&gt; which will grab &lt;a href=&quot;https://www.cloudflare.com/ips&quot;&gt;Cloudflare’s IP range list&lt;/a&gt; and output a file for use with the &lt;a href=&quot;https://nginx.org/en/docs/http/ngx_http_realip_module.html&quot;&gt;Real IPs nginx module&lt;/a&gt;. This is also the same script used in the traffic blocking section of the security section below, so if you wish to do both read on!&lt;/p&gt;

&lt;p&gt;To install the README does a good job of explaining, but essentially if you run this script it will start working like magic! You will need to automate this script (crontab recommended) to keep track of the Cloudflare IP range. A guide on how to is in the README for the script.&lt;/p&gt;

&lt;h1 id=&quot;security&quot;&gt;Security&lt;/h1&gt;

&lt;h3 id=&quot;cloudflare-security-settings&quot;&gt;Cloudflare Security Settings&lt;/h3&gt;

&lt;p&gt;Not related to nginx specifically (hence why it’s down here), but these are settings which are good to have on for your website in Cloudflare. Go to &lt;strong&gt;SSL/TLS-&amp;gt;Edge Certificates&lt;/strong&gt; to enable them:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/cloudflare-ssl-settings-1.png&quot; alt=&quot;Cloudflare SSL Settings 1&quot; /&gt;
&lt;img src=&quot;/assets/img/cloudflare-ssl-settings-2.png&quot; alt=&quot;Cloudflare SSL Settings 2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Feel free to &lt;strong&gt;turn HSTS on for subdomains&lt;/strong&gt;, I have it off since I do testing stuff on some of my subdomains, but it’s &lt;strong&gt;good practice to have on!&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&quot;disabling-security-tokens&quot;&gt;Disabling security tokens&lt;/h3&gt;

&lt;p&gt;You should be disabling security tokens on your nginx configuration which stops your nginx version being published on your website (typically shown on error pages). To do so go to your &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nginx.conf&lt;/code&gt; file which should be located at &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/etc/nginx/nginx.conf&lt;/code&gt; and add this line in the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;sudo nano /etc/nginx/nginx.conf&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;http {
	server_tokens off;
	...
	...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After restarting nginx &lt;strong&gt;sudo nginx -t and sudo systemctl restart nginx&lt;/strong&gt; any “bad” page or 404 error, etc, should now look like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/img/server-tokens-off.png&quot; alt=&quot;server-tokens-off&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;blocking-any-ports-you-reverse-proxy-from-being-public&quot;&gt;Blocking any ports you reverse proxy from being public&lt;/h3&gt;

&lt;p&gt;This one goes without saying, and while this guide doesn’t aim to be a reverse proxy how-to - it’s worth mentioning. If you reverse proxy a service through nginx, you most definitely should block it’s traffic (the port your reverse proxying through nginx) using a firewall such as UFW. I’m not going to write a guide on how-to do all this, but check out the &lt;a href=&quot;https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-20-04&quot;&gt;DigitalOcean tutorial here&lt;/a&gt; on how to get started with ufw. Just make sure your web server is accessible when you enable ufw, which is mentioned how to do in the article.&lt;/p&gt;

&lt;h2 id=&quot;end&quot;&gt;End&lt;/h2&gt;

&lt;p&gt;This is my first blog post so I don’t know how well this will be received, but hopefully this helps someone setting up nginx and wanting to be security conscious.&lt;/p&gt;</content><author><name>Thomas</name></author><category term="nginx" /><category term="security" /><category term="guide" /><summary type="html">I decided to write this as although a lot of guides on the internet provide a solid configuration for an nginx server, most of these guides will result in an IP leak somewhere under their configuration for the origin server somewhere. So you got your nginx server setup (hopefully) and it’s serving your files (or being an effective reverse proxy), but maybe you’ve noticed loading static content (images, media, etc) load slowly… or maybe you realised that anyone can get the IP address of your website and therefore the box which is hosting it, and that creeps you out a bit. Or maybe your website doesn’t have that padlock everyone else’s has and it’s “not secure”. Luckily all these issues can be solved by Cloudflare! Or maybe your website is going through Cloudflare but sometimes you notice your origin server is still publicly displaying the website, and you want to stop this leak. Unfortunately setting up Cloudflare for your website may seem simple, but setting it up securely and correctly to the inexperienced can be a difficult task. Although you may think your website is not leaking your origin IP address, it’s certainly possible that it is. This article will demonstrate how to secure your website through Cloudflare, and provide sample configurations to a hybrid nginx server which can be secure whether some vhosts are utilising Cloudflare and others aren’t (non-Cloudflare). This is not a complete guide on how to setup nginx for speed or anything like that, please just rely on this for securing your vhosts and origin server. This guide assumes you’re using the mainline version of nginx which will mean your sites are located in /etc/nginx/conf.d/ and your nginx user is nginx. To install the mainline version of nginx which is recommended by the nginx team follow this guide here - just remember this guide will not work with any version of Ubuntu except for 18.04 UNLESS you set the release name from bionic to your release name which you can find on Google. Maybe I’ll write my own guide :) Guide Step 1 - Generating a self-signed SSL certificate for your default server Why this is necessary This is a step that many guides on the internet do not do and instead they ask you to get a Cloudflare Origin TLS certificate for all your sites. While this is good practice because you can use Full (Strict) mode for your SSL on Cloudflare, it’s not good to implement if you wish to conceal the identity of your origin server. The reason why is because of this screenshot below. As you can see although no content is sent, the origin address of the website is exposed by the certificate being sent to the user. A simple web scraper could check the DNS of the certificate and easily expose the origin servers IP address. This is a Cloudflare and nginx website I setup where the default_server block will send a Cloudflare Origin TLS Certificate and required Authenticated Origin Pulls. Don’t worry if you don’t have these setup, these are the next steps in the guide (Authenticated Origin Pulls). For reference this was following the DigitalOcean nginx+Cloudflare guide Generating your certificate Well that’s out of the way, here’s how to generate it. You will need to make sure you have openssl installed on your system. This will generate a public and private certificate that will last for 15 years. Feel free to extend it. sudo openssl req -x509 -nodes -days 5475 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.pem -out /etc/ssl/certs/nginx-selfsigned.pem It will ask you for some values, just keep them as the default and maybe change your country name if desired. We will use this later in our nginx setup. Step 2 - Adding the Self Signed Certificate to nginx For this guide I’m assuming your nginx configurations are stored in /etc/nginx/conf.d/ mainline branch, otherwise you can follow along with /etc/nginx/sites-available/ Nginx will give us a default server file which will give you the following output once viewing your website: This file (default.conf) can be rewritten to default.old (if in conf.d) - or removed from your sites-enabled folder, and should be replaced with this new file: sudo nano /etc/nginx/conf.d/default.conf server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 403; } server { # SSL configuration listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; server_name _; return 403; } Then type sudo nginx -t to make sure your configuration is correct before typing sudo systemctl restart nginx to restart nginx to respond to the configuration change. This provides us with a base setup. If a request comes to the origin server and it does not have a server block it will come back as 403. Try test it out by going to the IP address of your box on http:// and https:// Step 3 - Configuring a host After this we can actually configure a host we would like to route properly through Cloudflare and nginx (yay)! aka something that isn’t our default_server. For the sake of this tutorial I’ve made a /var/www/ folder and have my nginx pointed to /var/www/test/ - the config is below. If you want to follow along, make sure you run these commands. 3.1 - Making a test host (skippable if you have content already) This little micro step is skippable if you have a host working already serving content. If you wish to skip click here to 3.2. mkdir -p /var/www/test/ sudo chown -R nginx:nginx /var/www/ sudo find /var/www -type f -exec chmod 664 {} \; sudo find /var/www -type d -exec chmod 775 {} \; sudo find /var/www -type d -exec chmod g+s {} \; I actually copied most of these perms from this guide. Essentially: changes the owner of /var/www to nginx and anyone in the nginx group. adds 644 permissions (-rw-rw-r–) to all files in /var/www. adds 775 permissions (drwxrwxr-x) to all directories in /var/www. sets the SGID bit on /var/www and all directories therein; This means that all new files and subdirectories created within the current directory inherit the group ID of the directory, rather than the primary group ID of the user who created the file. This will also be passed on to new subdirectories created in the current directory. Reminder if your nginx user is www-data the chown command should have www-data:www-data instead of nginx:nginx Make sure your user is in the nginx (or www-data) group, by typing groups USERNAME. If you cannot see the group listed, run: sudo usermod -aG nginx USERNAME and restart your shell. This will make the required folders and give nginx ownership of them. Essentially we are setting up our /var/www/ environment to be able to serve a website. 3.2 - Host Config Below is a sample of a nginx config that will simply display the static content of the website. If you have an existing host make sure you have any missing fields (namely the SSL certificate ones) - and the include file. Below is a few optimisations we can add to nginx to increase speed but also increase its security. Using a custom resolver Cloudflare’s DNS server will result in increased speed for any DNS queries your server runs. gzip compression will mean static content will be served faster. The SSL protocols changes will ensure only TLS 1.2 and TLS 1.3 are used between your site and your visitors (Cloudflare in this case) - resulting in a secure transport. The SSL ciphers listed are more safe and secure than the defaults and aid performance, which will help secure the communication between Cloudflare and your server. The dhparam setting will need an additional command to get working, but essentially it allows nginx to use pre-calculated field primes and generator values to reduce resource heavy calculations on your host. You will need to make an includes folder sudo mkdir /etc/nginx/includes then run this command to generate dhparams sudo openssl dhparam -out /etc/nginx/includes/dhparam.pem 4096 Then add this conf file: sudo nano /etc/nginx/includes/common_opts.conf resolver 1.1.1.1 1.0.0.1 valid=300s; resolver_timeout 10s; gzip on; gzip_vary on; gzip_min_length 1000; gzip_proxied any; gzip_comp_level 6; gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml; gzip_disable &quot;MSIE [1-6]\.&quot;; ssl_prefer_server_ciphers on; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS'; # use a dhparam ssl_dhparam /etc/nginx/includes/dhparam.pem; Here’s our base configuration file, make sure we import the conf file from the includes folder above. sudo nano /etc/nginx/conf.d/test.conf server { # SSL configuration listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; include /etc/nginx/includes/common_opts.conf; server_name testing.jfx.ac; location / { root /var/www/test index index.html; } } As you can see the config has no HTTP support, this is because Cloudflare can do automatic HTTPS rewrites, so why bother. Feel free to add this block in if you wish to have this functionality though. server { listen 80; listen [::]:80; server_name testing.jfx.ac; return 302 https://$server_name$request_uri; } Here is a friendly Hello World for HTML so we know it’s working :) nano /var/www/test/index.html &amp;lt;html&amp;gt; Hello World! &amp;lt;/html&amp;gt; And this will display our testing page when we go to our site, yay! Step 4 - Securing your hosts so only Cloudflare can access them Why As for why this is important, we can see that it appears the site is only serving the data if the user is going to the correct domain https://testing.jfx.ac - no way the origin can be exposed right? This is wrong. With a simple curl command it is easy to bypass the load balancer by spoofing our Host header. jfx@PC:~$ curl --insecure --header 'Host: testing.jfx.ac' 'https://167.172.213.53/' &amp;lt;html&amp;gt; Hello World! &amp;lt;/html&amp;gt; Scary stuff, what if someone was going through IP ranges and found our origin server this way? There’s actually a few ways to stop this, but the easiest way to stop this is to implement Authenticated Origin Pulls! More information is here from Cloudflare themselves. You can also block all HTTP/HTTPS traffic to your box unless it’s from Cloudflare using a firewall (such as UFW), this step is also explained but there are pros and cons for this which are listed below. Method Pros Cons Authenticated Origin Pulls Easier to setupCan use nginx for non Cloudflare hosts If your site is only using Cloudflare you just have an exposed web server with no purpose Firewall Blocking SafestBulletproof, no way for anyone except Cloudflare to access your web server Requires a firewall (like ufw) and a cronjob, slightly complicated setupFor Cloudflare only. Firewall will drop requests to nginx unless they are from Cloudflare 4.1 - Adding Authenticated Origin Pulls (easy) Firstly, make sure this feature is enabled on Cloudflare or the following steps will break your site. To enable it, go to Cloudflare and go to SSL/TLS -&amp;gt; Origin Server -&amp;gt; ON for Authenticated Origin Pulls: Next to setup Authenticated Origin Pulls on nginx, go here and at the bottom of the page download the origin-pull-ca.pem file. Once downloaded, copy its contents and output it to /etc/ssl/certs/cloudflare-origin.pem sudo nano /etc/ssl/certs/cloudflare-origin.pem *contents of origin-pull-ca.pem* Once that’s done, go back to your nginx config and add this to your SSL server block. sudo nano /etc/nginx/conf.d/test.conf ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; It should look like this server { # SSL configuration listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; include /etc/nginx/includes/common_opts.conf; server_name testing.jfx.ac; location / { root /var/www/test index index.html; } } A note: you do not need to use Cloudflare’s generated SSL certificates if you wish to use Authenticated Origin Pulls. Don’t forget to run sudo nginx -t and sudo systemctl restart nginx to reload your config! If we go to our website, we won’t notice a difference, but let’s try this curl spoof again: jfx@PC:~$ curl --insecure --header 'Host: testing.jfx.ac' 'https://167.172.213.53/' &amp;lt;html&amp;gt; &amp;lt;head&amp;gt;&amp;lt;title&amp;gt;400 No required SSL certificate was sent&amp;lt;/title&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;center&amp;gt;&amp;lt;h1&amp;gt;400 Bad Request&amp;lt;/h1&amp;gt;&amp;lt;/center&amp;gt; &amp;lt;center&amp;gt;No required SSL certificate was sent&amp;lt;/center&amp;gt; &amp;lt;hr&amp;gt;&amp;lt;center&amp;gt;nginx/1.19.1&amp;lt;/center&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Mad stuff, now we have protected our site from people trying to grab our origin IP address! There is a catch though, a 400 will return on any page where something is trying to spoof, but a 403 will return on the IP without a Host header. This gives away the fact that we are trying to be safe and only accept Cloudflare’s requests. A solution to this problem is simply adding the ssl_client_certificate and ssl_verify_client from above also to default.conf. With these, the error being returned will be consistent with that as the one shown above. To do this, edit default.conf and add those two lines in so it looks like this: sudo nano /etc/nginx/conf.d/default.conf server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 403; } server { # SSL configuration listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; server_name _; return 403; } With this there will be no way to determine whether or not the web server is trying to hide itself with a client certificate under a specific host. 4.2 - Blocking all HTTP/HTTPS traffic except for Cloudflare (safest) It is possible using iptables or ufw to block all web traffic coming to your server unless it’s from Cloudflare. Personally I think for a production environment this is the most safe and most bulletproof approach, as if you expect all your web traffic to come out of Cloudflare - there’s no benefit from having a public facing web server. From a security standpoint this is also the most effective. Whilst also enforcing the technique above (Authenticated Origin Pulls) you can add more security if you’re paranoid like me. The issue with this if you wish to have a host not go through Cloudflare, then this will not be possible (unless you whitelist visitors IPs). How to I have a handy script located here which will grab Cloudflare’s IP range list and output a file for use with the Real IPs nginx module. This script can also optionally add UFW rules for allowing Cloudflare IPs for https and http. If your UFW is set to block all incoming, then this will only allow incoming requests on ports 80 and 443 to Cloudflare IPs. I’m not going to write up how to setup UFW, there’s a nice DigitalOcean tutorial here. Just a word of caution: make sure you’ve disabled any existing HTTP/HTTPS rules before relying on this script. In the scripts README it tells you how to run it as a cron job so you stay on top of any updates to the Cloudflare IP range. Make sure you run the script as root and edit the UFW_RULES=false line to UFW_RULES=true Discussion I’m going to break the discussion into two sections: Common issues you may have with a Cloudflare setup and how to resolve them Even tougher security methods than shown above (but are worth looking at!) Common issues nginx not displaying Real IPs for any visitor! I have a handy script located here which will grab Cloudflare’s IP range list and output a file for use with the Real IPs nginx module. This is also the same script used in the traffic blocking section of the security section below, so if you wish to do both read on! To install the README does a good job of explaining, but essentially if you run this script it will start working like magic! You will need to automate this script (crontab recommended) to keep track of the Cloudflare IP range. A guide on how to is in the README for the script. Security Cloudflare Security Settings Not related to nginx specifically (hence why it’s down here), but these are settings which are good to have on for your website in Cloudflare. Go to SSL/TLS-&amp;gt;Edge Certificates to enable them: Feel free to turn HSTS on for subdomains, I have it off since I do testing stuff on some of my subdomains, but it’s good practice to have on! Disabling security tokens You should be disabling security tokens on your nginx configuration which stops your nginx version being published on your website (typically shown on error pages). To do so go to your nginx.conf file which should be located at /etc/nginx/nginx.conf and add this line in the http block. sudo nano /etc/nginx/nginx.conf http { server_tokens off; ... ... } After restarting nginx sudo nginx -t and sudo systemctl restart nginx any “bad” page or 404 error, etc, should now look like this: Blocking any ports you reverse proxy from being public This one goes without saying, and while this guide doesn’t aim to be a reverse proxy how-to - it’s worth mentioning. If you reverse proxy a service through nginx, you most definitely should block it’s traffic (the port your reverse proxying through nginx) using a firewall such as UFW. I’m not going to write a guide on how-to do all this, but check out the DigitalOcean tutorial here on how to get started with ufw. Just make sure your web server is accessible when you enable ufw, which is mentioned how to do in the article. End This is my first blog post so I don’t know how well this will be received, but hopefully this helps someone setting up nginx and wanting to be security conscious.</summary></entry></feed>