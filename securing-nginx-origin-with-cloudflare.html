<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.7.1 -->
<title>How to secure your nginx + Cloudflare configuration to stop any origin leaks | jfx Blog</title>
<meta name="generator" content="Jekyll v4.2.0" />
<meta property="og:title" content="How to secure your nginx + Cloudflare configuration to stop any origin leaks" />
<meta name="author" content="Thomas" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I decided to write this as although a lot of guides on the internet provide a solid configuration for an nginx server, most of these guides will result in an IP leak somewhere under their configuration for the origin server somewhere. So you got your nginx server setup (hopefully) and it’s serving your files (or being an effective reverse proxy), but maybe you’ve noticed loading static content (images, media, etc) load slowly… or maybe you realised that anyone can get the IP address of your website and therefore the box which is hosting it, and that creeps you out a bit. Or maybe your website doesn’t have that padlock everyone else’s has and it’s “not secure”. Luckily all these issues can be solved by Cloudflare! Or maybe your website is going through Cloudflare but sometimes you notice your origin server is still publicly displaying the website, and you want to stop this leak. Unfortunately setting up Cloudflare for your website may seem simple, but setting it up securely and correctly to the inexperienced can be a difficult task. Although you may think your website is not leaking your origin IP address, it’s certainly possible that it is. This article will demonstrate how to secure your website through Cloudflare, and provide sample configurations to a hybrid nginx server which can be secure whether some vhosts are utilising Cloudflare and others aren’t (non-Cloudflare). This is not a complete guide on how to setup nginx for speed or anything like that, please just rely on this for securing your vhosts and origin server. This guide assumes you’re using the mainline version of nginx which will mean your sites are located in /etc/nginx/conf.d/ and your nginx user is nginx. To install the mainline version of nginx which is recommended by the nginx team follow this guide here - just remember this guide will not work with any version of Ubuntu except for 18.04 UNLESS you set the release name from bionic to your release name which you can find on Google. Maybe I’ll write my own guide :) Guide Step 1 - Generating a self-signed SSL certificate for your default server Why this is necessary This is a step that many guides on the internet do not do and instead they ask you to get a Cloudflare Origin TLS certificate for all your sites. While this is good practice because you can use Full (Strict) mode for your SSL on Cloudflare, it’s not good to implement if you wish to conceal the identity of your origin server. The reason why is because of this screenshot below. As you can see although no content is sent, the origin address of the website is exposed by the certificate being sent to the user. A simple web scraper could check the DNS of the certificate and easily expose the origin servers IP address. This is a Cloudflare and nginx website I setup where the default_server block will send a Cloudflare Origin TLS Certificate and required Authenticated Origin Pulls. Don’t worry if you don’t have these setup, these are the next steps in the guide (Authenticated Origin Pulls). For reference this was following the DigitalOcean nginx+Cloudflare guide Generating your certificate Well that’s out of the way, here’s how to generate it. You will need to make sure you have openssl installed on your system. This will generate a public and private certificate that will last for 15 years. Feel free to extend it. sudo openssl req -x509 -nodes -days 5475 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.pem -out /etc/ssl/certs/nginx-selfsigned.pem It will ask you for some values, just keep them as the default and maybe change your country name if desired. We will use this later in our nginx setup. Step 2 - Adding the Self Signed Certificate to nginx For this guide I’m assuming your nginx configurations are stored in /etc/nginx/conf.d/ mainline branch, otherwise you can follow along with /etc/nginx/sites-available/ Nginx will give us a default server file which will give you the following output once viewing your website: This file (default.conf) can be rewritten to default.old (if in conf.d) - or removed from your sites-enabled folder, and should be replaced with this new file: sudo nano /etc/nginx/conf.d/default.conf server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 403; } server { # SSL configuration listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; server_name _; return 403; } Then type sudo nginx -t to make sure your configuration is correct before typing sudo systemctl restart nginx to restart nginx to respond to the configuration change. This provides us with a base setup. If a request comes to the origin server and it does not have a server block it will come back as 403. Try test it out by going to the IP address of your box on http:// and https:// Step 3 - Configuring a host After this we can actually configure a host we would like to route properly through Cloudflare and nginx (yay)! aka something that isn’t our default_server. For the sake of this tutorial I’ve made a /var/www/ folder and have my nginx pointed to /var/www/test/ - the config is below. If you want to follow along, make sure you run these commands. 3.1 - Making a test host (skippable if you have content already) This little micro step is skippable if you have a host working already serving content. If you wish to skip click here to 3.2. mkdir -p /var/www/test/ sudo chown -R nginx:nginx /var/www/ sudo find /var/www -type f -exec chmod 664 {} \; sudo find /var/www -type d -exec chmod 775 {} \; sudo find /var/www -type d -exec chmod g+s {} \; I actually copied most of these perms from this guide. Essentially: changes the owner of /var/www to nginx and anyone in the nginx group. adds 644 permissions (-rw-rw-r–) to all files in /var/www. adds 775 permissions (drwxrwxr-x) to all directories in /var/www. sets the SGID bit on /var/www and all directories therein; This means that all new files and subdirectories created within the current directory inherit the group ID of the directory, rather than the primary group ID of the user who created the file. This will also be passed on to new subdirectories created in the current directory. Reminder if your nginx user is www-data the chown command should have www-data:www-data instead of nginx:nginx Make sure your user is in the nginx (or www-data) group, by typing groups USERNAME. If you cannot see the group listed, run: sudo usermod -aG nginx USERNAME and restart your shell. This will make the required folders and give nginx ownership of them. Essentially we are setting up our /var/www/ environment to be able to serve a website. 3.2 - Host Config Below is a sample of a nginx config that will simply display the static content of the website. If you have an existing host make sure you have any missing fields (namely the SSL certificate ones) - and the include file. Below is a few optimisations we can add to nginx to increase speed but also increase its security. Using a custom resolver Cloudflare’s DNS server will result in increased speed for any DNS queries your server runs. gzip compression will mean static content will be served faster. The SSL protocols changes will ensure only TLS 1.2 and TLS 1.3 are used between your site and your visitors (Cloudflare in this case) - resulting in a secure transport. The SSL ciphers listed are more safe and secure than the defaults and aid performance, which will help secure the communication between Cloudflare and your server. The dhparam setting will need an additional command to get working, but essentially it allows nginx to use pre-calculated field primes and generator values to reduce resource heavy calculations on your host. You will need to make an includes folder sudo mkdir /etc/nginx/includes then run this command to generate dhparams sudo openssl dhparam -out /etc/nginx/includes/dhparam.pem 4096 Then add this conf file: sudo nano /etc/nginx/includes/common_opts.conf resolver 1.1.1.1 1.0.0.1 valid=300s; resolver_timeout 10s; gzip on; gzip_vary on; gzip_min_length 1000; gzip_proxied any; gzip_comp_level 6; gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml; gzip_disable &quot;MSIE [1-6]\.&quot;; ssl_prefer_server_ciphers on; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers &#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&#39;; # use a dhparam ssl_dhparam /etc/nginx/includes/dhparam.pem; Here’s our base configuration file, make sure we import the conf file from the includes folder above. sudo nano /etc/nginx/conf.d/test.conf server { # SSL configuration listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; include /etc/nginx/includes/common_opts.conf; server_name testing.jfx.ac; location / { root /var/www/test index index.html; } } As you can see the config has no HTTP support, this is because Cloudflare can do automatic HTTPS rewrites, so why bother. Feel free to add this block in if you wish to have this functionality though. server { listen 80; listen [::]:80; server_name testing.jfx.ac; return 302 https://$server_name$request_uri; } Here is a friendly Hello World for HTML so we know it’s working :) nano /var/www/test/index.html &lt;html&gt; Hello World! &lt;/html&gt; And this will display our testing page when we go to our site, yay! Step 4 - Securing your hosts so only Cloudflare can access them Why As for why this is important, we can see that it appears the site is only serving the data if the user is going to the correct domain https://testing.jfx.ac - no way the origin can be exposed right? This is wrong. With a simple curl command it is easy to bypass the load balancer by spoofing our Host header. jfx@PC:~$ curl --insecure --header &#39;Host: testing.jfx.ac&#39; &#39;https://167.172.213.53/&#39; &lt;html&gt; Hello World! &lt;/html&gt; Scary stuff, what if someone was going through IP ranges and found our origin server this way? There’s actually a few ways to stop this, but the easiest way to stop this is to implement Authenticated Origin Pulls! More information is here from Cloudflare themselves. You can also block all HTTP/HTTPS traffic to your box unless it’s from Cloudflare using a firewall (such as UFW), this step is also explained but there are pros and cons for this which are listed below. Method Pros Cons Authenticated Origin Pulls Easier to setupCan use nginx for non Cloudflare hosts If your site is only using Cloudflare you just have an exposed web server with no purpose Firewall Blocking SafestBulletproof, no way for anyone except Cloudflare to access your web server Requires a firewall (like ufw) and a cronjob, slightly complicated setupFor Cloudflare only. Firewall will drop requests to nginx unless they are from Cloudflare 4.1 - Adding Authenticated Origin Pulls (easy) Firstly, make sure this feature is enabled on Cloudflare or the following steps will break your site. To enable it, go to Cloudflare and go to SSL/TLS -&gt; Origin Server -&gt; ON for Authenticated Origin Pulls: Next to setup Authenticated Origin Pulls on nginx, go here and at the bottom of the page download the origin-pull-ca.pem file. Once downloaded, copy its contents and output it to /etc/ssl/certs/cloudflare-origin.pem sudo nano /etc/ssl/certs/cloudflare-origin.pem *contents of origin-pull-ca.pem* Once that’s done, go back to your nginx config and add this to your SSL server block. sudo nano /etc/nginx/conf.d/test.conf ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; It should look like this server { # SSL configuration listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; include /etc/nginx/includes/common_opts.conf; server_name testing.jfx.ac; location / { root /var/www/test index index.html; } } A note: you do not need to use Cloudflare’s generated SSL certificates if you wish to use Authenticated Origin Pulls. Don’t forget to run sudo nginx -t and sudo systemctl restart nginx to reload your config! If we go to our website, we won’t notice a difference, but let’s try this curl spoof again: jfx@PC:~$ curl --insecure --header &#39;Host: testing.jfx.ac&#39; &#39;https://167.172.213.53/&#39; &lt;html&gt; &lt;head&gt;&lt;title&gt;400 No required SSL certificate was sent&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;No required SSL certificate was sent&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx/1.19.1&lt;/center&gt; &lt;/body&gt; &lt;/html&gt; Mad stuff, now we have protected our site from people trying to grab our origin IP address! There is a catch though, a 400 will return on any page where something is trying to spoof, but a 403 will return on the IP without a Host header. This gives away the fact that we are trying to be safe and only accept Cloudflare’s requests. A solution to this problem is simply adding the ssl_client_certificate and ssl_verify_client from above also to default.conf. With these, the error being returned will be consistent with that as the one shown above. To do this, edit default.conf and add those two lines in so it looks like this: sudo nano /etc/nginx/conf.d/default.conf server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 403; } server { # SSL configuration listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; server_name _; return 403; } With this there will be no way to determine whether or not the web server is trying to hide itself with a client certificate under a specific host. 4.2 - Blocking all HTTP/HTTPS traffic except for Cloudflare (safest) It is possible using iptables or ufw to block all web traffic coming to your server unless it’s from Cloudflare. Personally I think for a production environment this is the most safe and most bulletproof approach, as if you expect all your web traffic to come out of Cloudflare - there’s no benefit from having a public facing web server. From a security standpoint this is also the most effective. Whilst also enforcing the technique above (Authenticated Origin Pulls) you can add more security if you’re paranoid like me. The issue with this if you wish to have a host not go through Cloudflare, then this will not be possible (unless you whitelist visitors IPs). How to I have a handy script located here which will grab Cloudflare’s IP range list and output a file for use with the Real IPs nginx module. This script can also optionally add UFW rules for allowing Cloudflare IPs for https and http. If your UFW is set to block all incoming, then this will only allow incoming requests on ports 80 and 443 to Cloudflare IPs. I’m not going to write up how to setup UFW, there’s a nice DigitalOcean tutorial here. Just a word of caution: make sure you’ve disabled any existing HTTP/HTTPS rules before relying on this script. In the scripts README it tells you how to run it as a cron job so you stay on top of any updates to the Cloudflare IP range. Make sure you run the script as root and edit the UFW_RULES=false line to UFW_RULES=true Discussion I’m going to break the discussion into two sections: Common issues you may have with a Cloudflare setup and how to resolve them Even tougher security methods than shown above (but are worth looking at!) Common issues nginx not displaying Real IPs for any visitor! I have a handy script located here which will grab Cloudflare’s IP range list and output a file for use with the Real IPs nginx module. This is also the same script used in the traffic blocking section of the security section below, so if you wish to do both read on! To install the README does a good job of explaining, but essentially if you run this script it will start working like magic! You will need to automate this script (crontab recommended) to keep track of the Cloudflare IP range. A guide on how to is in the README for the script. Security Cloudflare Security Settings Not related to nginx specifically (hence why it’s down here), but these are settings which are good to have on for your website in Cloudflare. Go to SSL/TLS-&gt;Edge Certificates to enable them: Feel free to turn HSTS on for subdomains, I have it off since I do testing stuff on some of my subdomains, but it’s good practice to have on! Disabling security tokens You should be disabling security tokens on your nginx configuration which stops your nginx version being published on your website (typically shown on error pages). To do so go to your nginx.conf file which should be located at /etc/nginx/nginx.conf and add this line in the http block. sudo nano /etc/nginx/nginx.conf http { server_tokens off; ... ... } After restarting nginx sudo nginx -t and sudo systemctl restart nginx any “bad” page or 404 error, etc, should now look like this: Blocking any ports you reverse proxy from being public This one goes without saying, and while this guide doesn’t aim to be a reverse proxy how-to - it’s worth mentioning. If you reverse proxy a service through nginx, you most definitely should block it’s traffic (the port your reverse proxying through nginx) using a firewall such as UFW. I’m not going to write a guide on how-to do all this, but check out the DigitalOcean tutorial here on how to get started with ufw. Just make sure your web server is accessible when you enable ufw, which is mentioned how to do in the article. End This is my first blog post so I don’t know how well this will be received, but hopefully this helps someone setting up nginx and wanting to be security conscious." />
<meta property="og:description" content="I decided to write this as although a lot of guides on the internet provide a solid configuration for an nginx server, most of these guides will result in an IP leak somewhere under their configuration for the origin server somewhere. So you got your nginx server setup (hopefully) and it’s serving your files (or being an effective reverse proxy), but maybe you’ve noticed loading static content (images, media, etc) load slowly… or maybe you realised that anyone can get the IP address of your website and therefore the box which is hosting it, and that creeps you out a bit. Or maybe your website doesn’t have that padlock everyone else’s has and it’s “not secure”. Luckily all these issues can be solved by Cloudflare! Or maybe your website is going through Cloudflare but sometimes you notice your origin server is still publicly displaying the website, and you want to stop this leak. Unfortunately setting up Cloudflare for your website may seem simple, but setting it up securely and correctly to the inexperienced can be a difficult task. Although you may think your website is not leaking your origin IP address, it’s certainly possible that it is. This article will demonstrate how to secure your website through Cloudflare, and provide sample configurations to a hybrid nginx server which can be secure whether some vhosts are utilising Cloudflare and others aren’t (non-Cloudflare). This is not a complete guide on how to setup nginx for speed or anything like that, please just rely on this for securing your vhosts and origin server. This guide assumes you’re using the mainline version of nginx which will mean your sites are located in /etc/nginx/conf.d/ and your nginx user is nginx. To install the mainline version of nginx which is recommended by the nginx team follow this guide here - just remember this guide will not work with any version of Ubuntu except for 18.04 UNLESS you set the release name from bionic to your release name which you can find on Google. Maybe I’ll write my own guide :) Guide Step 1 - Generating a self-signed SSL certificate for your default server Why this is necessary This is a step that many guides on the internet do not do and instead they ask you to get a Cloudflare Origin TLS certificate for all your sites. While this is good practice because you can use Full (Strict) mode for your SSL on Cloudflare, it’s not good to implement if you wish to conceal the identity of your origin server. The reason why is because of this screenshot below. As you can see although no content is sent, the origin address of the website is exposed by the certificate being sent to the user. A simple web scraper could check the DNS of the certificate and easily expose the origin servers IP address. This is a Cloudflare and nginx website I setup where the default_server block will send a Cloudflare Origin TLS Certificate and required Authenticated Origin Pulls. Don’t worry if you don’t have these setup, these are the next steps in the guide (Authenticated Origin Pulls). For reference this was following the DigitalOcean nginx+Cloudflare guide Generating your certificate Well that’s out of the way, here’s how to generate it. You will need to make sure you have openssl installed on your system. This will generate a public and private certificate that will last for 15 years. Feel free to extend it. sudo openssl req -x509 -nodes -days 5475 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.pem -out /etc/ssl/certs/nginx-selfsigned.pem It will ask you for some values, just keep them as the default and maybe change your country name if desired. We will use this later in our nginx setup. Step 2 - Adding the Self Signed Certificate to nginx For this guide I’m assuming your nginx configurations are stored in /etc/nginx/conf.d/ mainline branch, otherwise you can follow along with /etc/nginx/sites-available/ Nginx will give us a default server file which will give you the following output once viewing your website: This file (default.conf) can be rewritten to default.old (if in conf.d) - or removed from your sites-enabled folder, and should be replaced with this new file: sudo nano /etc/nginx/conf.d/default.conf server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 403; } server { # SSL configuration listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; server_name _; return 403; } Then type sudo nginx -t to make sure your configuration is correct before typing sudo systemctl restart nginx to restart nginx to respond to the configuration change. This provides us with a base setup. If a request comes to the origin server and it does not have a server block it will come back as 403. Try test it out by going to the IP address of your box on http:// and https:// Step 3 - Configuring a host After this we can actually configure a host we would like to route properly through Cloudflare and nginx (yay)! aka something that isn’t our default_server. For the sake of this tutorial I’ve made a /var/www/ folder and have my nginx pointed to /var/www/test/ - the config is below. If you want to follow along, make sure you run these commands. 3.1 - Making a test host (skippable if you have content already) This little micro step is skippable if you have a host working already serving content. If you wish to skip click here to 3.2. mkdir -p /var/www/test/ sudo chown -R nginx:nginx /var/www/ sudo find /var/www -type f -exec chmod 664 {} \; sudo find /var/www -type d -exec chmod 775 {} \; sudo find /var/www -type d -exec chmod g+s {} \; I actually copied most of these perms from this guide. Essentially: changes the owner of /var/www to nginx and anyone in the nginx group. adds 644 permissions (-rw-rw-r–) to all files in /var/www. adds 775 permissions (drwxrwxr-x) to all directories in /var/www. sets the SGID bit on /var/www and all directories therein; This means that all new files and subdirectories created within the current directory inherit the group ID of the directory, rather than the primary group ID of the user who created the file. This will also be passed on to new subdirectories created in the current directory. Reminder if your nginx user is www-data the chown command should have www-data:www-data instead of nginx:nginx Make sure your user is in the nginx (or www-data) group, by typing groups USERNAME. If you cannot see the group listed, run: sudo usermod -aG nginx USERNAME and restart your shell. This will make the required folders and give nginx ownership of them. Essentially we are setting up our /var/www/ environment to be able to serve a website. 3.2 - Host Config Below is a sample of a nginx config that will simply display the static content of the website. If you have an existing host make sure you have any missing fields (namely the SSL certificate ones) - and the include file. Below is a few optimisations we can add to nginx to increase speed but also increase its security. Using a custom resolver Cloudflare’s DNS server will result in increased speed for any DNS queries your server runs. gzip compression will mean static content will be served faster. The SSL protocols changes will ensure only TLS 1.2 and TLS 1.3 are used between your site and your visitors (Cloudflare in this case) - resulting in a secure transport. The SSL ciphers listed are more safe and secure than the defaults and aid performance, which will help secure the communication between Cloudflare and your server. The dhparam setting will need an additional command to get working, but essentially it allows nginx to use pre-calculated field primes and generator values to reduce resource heavy calculations on your host. You will need to make an includes folder sudo mkdir /etc/nginx/includes then run this command to generate dhparams sudo openssl dhparam -out /etc/nginx/includes/dhparam.pem 4096 Then add this conf file: sudo nano /etc/nginx/includes/common_opts.conf resolver 1.1.1.1 1.0.0.1 valid=300s; resolver_timeout 10s; gzip on; gzip_vary on; gzip_min_length 1000; gzip_proxied any; gzip_comp_level 6; gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml; gzip_disable &quot;MSIE [1-6]\.&quot;; ssl_prefer_server_ciphers on; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers &#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&#39;; # use a dhparam ssl_dhparam /etc/nginx/includes/dhparam.pem; Here’s our base configuration file, make sure we import the conf file from the includes folder above. sudo nano /etc/nginx/conf.d/test.conf server { # SSL configuration listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; include /etc/nginx/includes/common_opts.conf; server_name testing.jfx.ac; location / { root /var/www/test index index.html; } } As you can see the config has no HTTP support, this is because Cloudflare can do automatic HTTPS rewrites, so why bother. Feel free to add this block in if you wish to have this functionality though. server { listen 80; listen [::]:80; server_name testing.jfx.ac; return 302 https://$server_name$request_uri; } Here is a friendly Hello World for HTML so we know it’s working :) nano /var/www/test/index.html &lt;html&gt; Hello World! &lt;/html&gt; And this will display our testing page when we go to our site, yay! Step 4 - Securing your hosts so only Cloudflare can access them Why As for why this is important, we can see that it appears the site is only serving the data if the user is going to the correct domain https://testing.jfx.ac - no way the origin can be exposed right? This is wrong. With a simple curl command it is easy to bypass the load balancer by spoofing our Host header. jfx@PC:~$ curl --insecure --header &#39;Host: testing.jfx.ac&#39; &#39;https://167.172.213.53/&#39; &lt;html&gt; Hello World! &lt;/html&gt; Scary stuff, what if someone was going through IP ranges and found our origin server this way? There’s actually a few ways to stop this, but the easiest way to stop this is to implement Authenticated Origin Pulls! More information is here from Cloudflare themselves. You can also block all HTTP/HTTPS traffic to your box unless it’s from Cloudflare using a firewall (such as UFW), this step is also explained but there are pros and cons for this which are listed below. Method Pros Cons Authenticated Origin Pulls Easier to setupCan use nginx for non Cloudflare hosts If your site is only using Cloudflare you just have an exposed web server with no purpose Firewall Blocking SafestBulletproof, no way for anyone except Cloudflare to access your web server Requires a firewall (like ufw) and a cronjob, slightly complicated setupFor Cloudflare only. Firewall will drop requests to nginx unless they are from Cloudflare 4.1 - Adding Authenticated Origin Pulls (easy) Firstly, make sure this feature is enabled on Cloudflare or the following steps will break your site. To enable it, go to Cloudflare and go to SSL/TLS -&gt; Origin Server -&gt; ON for Authenticated Origin Pulls: Next to setup Authenticated Origin Pulls on nginx, go here and at the bottom of the page download the origin-pull-ca.pem file. Once downloaded, copy its contents and output it to /etc/ssl/certs/cloudflare-origin.pem sudo nano /etc/ssl/certs/cloudflare-origin.pem *contents of origin-pull-ca.pem* Once that’s done, go back to your nginx config and add this to your SSL server block. sudo nano /etc/nginx/conf.d/test.conf ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; It should look like this server { # SSL configuration listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; include /etc/nginx/includes/common_opts.conf; server_name testing.jfx.ac; location / { root /var/www/test index index.html; } } A note: you do not need to use Cloudflare’s generated SSL certificates if you wish to use Authenticated Origin Pulls. Don’t forget to run sudo nginx -t and sudo systemctl restart nginx to reload your config! If we go to our website, we won’t notice a difference, but let’s try this curl spoof again: jfx@PC:~$ curl --insecure --header &#39;Host: testing.jfx.ac&#39; &#39;https://167.172.213.53/&#39; &lt;html&gt; &lt;head&gt;&lt;title&gt;400 No required SSL certificate was sent&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;No required SSL certificate was sent&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx/1.19.1&lt;/center&gt; &lt;/body&gt; &lt;/html&gt; Mad stuff, now we have protected our site from people trying to grab our origin IP address! There is a catch though, a 400 will return on any page where something is trying to spoof, but a 403 will return on the IP without a Host header. This gives away the fact that we are trying to be safe and only accept Cloudflare’s requests. A solution to this problem is simply adding the ssl_client_certificate and ssl_verify_client from above also to default.conf. With these, the error being returned will be consistent with that as the one shown above. To do this, edit default.conf and add those two lines in so it looks like this: sudo nano /etc/nginx/conf.d/default.conf server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 403; } server { # SSL configuration listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; server_name _; return 403; } With this there will be no way to determine whether or not the web server is trying to hide itself with a client certificate under a specific host. 4.2 - Blocking all HTTP/HTTPS traffic except for Cloudflare (safest) It is possible using iptables or ufw to block all web traffic coming to your server unless it’s from Cloudflare. Personally I think for a production environment this is the most safe and most bulletproof approach, as if you expect all your web traffic to come out of Cloudflare - there’s no benefit from having a public facing web server. From a security standpoint this is also the most effective. Whilst also enforcing the technique above (Authenticated Origin Pulls) you can add more security if you’re paranoid like me. The issue with this if you wish to have a host not go through Cloudflare, then this will not be possible (unless you whitelist visitors IPs). How to I have a handy script located here which will grab Cloudflare’s IP range list and output a file for use with the Real IPs nginx module. This script can also optionally add UFW rules for allowing Cloudflare IPs for https and http. If your UFW is set to block all incoming, then this will only allow incoming requests on ports 80 and 443 to Cloudflare IPs. I’m not going to write up how to setup UFW, there’s a nice DigitalOcean tutorial here. Just a word of caution: make sure you’ve disabled any existing HTTP/HTTPS rules before relying on this script. In the scripts README it tells you how to run it as a cron job so you stay on top of any updates to the Cloudflare IP range. Make sure you run the script as root and edit the UFW_RULES=false line to UFW_RULES=true Discussion I’m going to break the discussion into two sections: Common issues you may have with a Cloudflare setup and how to resolve them Even tougher security methods than shown above (but are worth looking at!) Common issues nginx not displaying Real IPs for any visitor! I have a handy script located here which will grab Cloudflare’s IP range list and output a file for use with the Real IPs nginx module. This is also the same script used in the traffic blocking section of the security section below, so if you wish to do both read on! To install the README does a good job of explaining, but essentially if you run this script it will start working like magic! You will need to automate this script (crontab recommended) to keep track of the Cloudflare IP range. A guide on how to is in the README for the script. Security Cloudflare Security Settings Not related to nginx specifically (hence why it’s down here), but these are settings which are good to have on for your website in Cloudflare. Go to SSL/TLS-&gt;Edge Certificates to enable them: Feel free to turn HSTS on for subdomains, I have it off since I do testing stuff on some of my subdomains, but it’s good practice to have on! Disabling security tokens You should be disabling security tokens on your nginx configuration which stops your nginx version being published on your website (typically shown on error pages). To do so go to your nginx.conf file which should be located at /etc/nginx/nginx.conf and add this line in the http block. sudo nano /etc/nginx/nginx.conf http { server_tokens off; ... ... } After restarting nginx sudo nginx -t and sudo systemctl restart nginx any “bad” page or 404 error, etc, should now look like this: Blocking any ports you reverse proxy from being public This one goes without saying, and while this guide doesn’t aim to be a reverse proxy how-to - it’s worth mentioning. If you reverse proxy a service through nginx, you most definitely should block it’s traffic (the port your reverse proxying through nginx) using a firewall such as UFW. I’m not going to write a guide on how-to do all this, but check out the DigitalOcean tutorial here on how to get started with ufw. Just make sure your web server is accessible when you enable ufw, which is mentioned how to do in the article. End This is my first blog post so I don’t know how well this will be received, but hopefully this helps someone setting up nginx and wanting to be security conscious." />
<link rel="canonical" href="https://blog.jfx.ac/securing-nginx-origin-with-cloudflare.html" />
<meta property="og:url" content="https://blog.jfx.ac/securing-nginx-origin-with-cloudflare.html" />
<meta property="og:site_name" content="jfx Blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-08-03T04:42:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="How to secure your nginx + Cloudflare configuration to stop any origin leaks" />
<script type="application/ld+json">
{"description":"I decided to write this as although a lot of guides on the internet provide a solid configuration for an nginx server, most of these guides will result in an IP leak somewhere under their configuration for the origin server somewhere. So you got your nginx server setup (hopefully) and it’s serving your files (or being an effective reverse proxy), but maybe you’ve noticed loading static content (images, media, etc) load slowly… or maybe you realised that anyone can get the IP address of your website and therefore the box which is hosting it, and that creeps you out a bit. Or maybe your website doesn’t have that padlock everyone else’s has and it’s “not secure”. Luckily all these issues can be solved by Cloudflare! Or maybe your website is going through Cloudflare but sometimes you notice your origin server is still publicly displaying the website, and you want to stop this leak. Unfortunately setting up Cloudflare for your website may seem simple, but setting it up securely and correctly to the inexperienced can be a difficult task. Although you may think your website is not leaking your origin IP address, it’s certainly possible that it is. This article will demonstrate how to secure your website through Cloudflare, and provide sample configurations to a hybrid nginx server which can be secure whether some vhosts are utilising Cloudflare and others aren’t (non-Cloudflare). This is not a complete guide on how to setup nginx for speed or anything like that, please just rely on this for securing your vhosts and origin server. This guide assumes you’re using the mainline version of nginx which will mean your sites are located in /etc/nginx/conf.d/ and your nginx user is nginx. To install the mainline version of nginx which is recommended by the nginx team follow this guide here - just remember this guide will not work with any version of Ubuntu except for 18.04 UNLESS you set the release name from bionic to your release name which you can find on Google. Maybe I’ll write my own guide :) Guide Step 1 - Generating a self-signed SSL certificate for your default server Why this is necessary This is a step that many guides on the internet do not do and instead they ask you to get a Cloudflare Origin TLS certificate for all your sites. While this is good practice because you can use Full (Strict) mode for your SSL on Cloudflare, it’s not good to implement if you wish to conceal the identity of your origin server. The reason why is because of this screenshot below. As you can see although no content is sent, the origin address of the website is exposed by the certificate being sent to the user. A simple web scraper could check the DNS of the certificate and easily expose the origin servers IP address. This is a Cloudflare and nginx website I setup where the default_server block will send a Cloudflare Origin TLS Certificate and required Authenticated Origin Pulls. Don’t worry if you don’t have these setup, these are the next steps in the guide (Authenticated Origin Pulls). For reference this was following the DigitalOcean nginx+Cloudflare guide Generating your certificate Well that’s out of the way, here’s how to generate it. You will need to make sure you have openssl installed on your system. This will generate a public and private certificate that will last for 15 years. Feel free to extend it. sudo openssl req -x509 -nodes -days 5475 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.pem -out /etc/ssl/certs/nginx-selfsigned.pem It will ask you for some values, just keep them as the default and maybe change your country name if desired. We will use this later in our nginx setup. Step 2 - Adding the Self Signed Certificate to nginx For this guide I’m assuming your nginx configurations are stored in /etc/nginx/conf.d/ mainline branch, otherwise you can follow along with /etc/nginx/sites-available/ Nginx will give us a default server file which will give you the following output once viewing your website: This file (default.conf) can be rewritten to default.old (if in conf.d) - or removed from your sites-enabled folder, and should be replaced with this new file: sudo nano /etc/nginx/conf.d/default.conf server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 403; } server { # SSL configuration listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; server_name _; return 403; } Then type sudo nginx -t to make sure your configuration is correct before typing sudo systemctl restart nginx to restart nginx to respond to the configuration change. This provides us with a base setup. If a request comes to the origin server and it does not have a server block it will come back as 403. Try test it out by going to the IP address of your box on http:// and https:// Step 3 - Configuring a host After this we can actually configure a host we would like to route properly through Cloudflare and nginx (yay)! aka something that isn’t our default_server. For the sake of this tutorial I’ve made a /var/www/ folder and have my nginx pointed to /var/www/test/ - the config is below. If you want to follow along, make sure you run these commands. 3.1 - Making a test host (skippable if you have content already) This little micro step is skippable if you have a host working already serving content. If you wish to skip click here to 3.2. mkdir -p /var/www/test/ sudo chown -R nginx:nginx /var/www/ sudo find /var/www -type f -exec chmod 664 {} \\; sudo find /var/www -type d -exec chmod 775 {} \\; sudo find /var/www -type d -exec chmod g+s {} \\; I actually copied most of these perms from this guide. Essentially: changes the owner of /var/www to nginx and anyone in the nginx group. adds 644 permissions (-rw-rw-r–) to all files in /var/www. adds 775 permissions (drwxrwxr-x) to all directories in /var/www. sets the SGID bit on /var/www and all directories therein; This means that all new files and subdirectories created within the current directory inherit the group ID of the directory, rather than the primary group ID of the user who created the file. This will also be passed on to new subdirectories created in the current directory. Reminder if your nginx user is www-data the chown command should have www-data:www-data instead of nginx:nginx Make sure your user is in the nginx (or www-data) group, by typing groups USERNAME. If you cannot see the group listed, run: sudo usermod -aG nginx USERNAME and restart your shell. This will make the required folders and give nginx ownership of them. Essentially we are setting up our /var/www/ environment to be able to serve a website. 3.2 - Host Config Below is a sample of a nginx config that will simply display the static content of the website. If you have an existing host make sure you have any missing fields (namely the SSL certificate ones) - and the include file. Below is a few optimisations we can add to nginx to increase speed but also increase its security. Using a custom resolver Cloudflare’s DNS server will result in increased speed for any DNS queries your server runs. gzip compression will mean static content will be served faster. The SSL protocols changes will ensure only TLS 1.2 and TLS 1.3 are used between your site and your visitors (Cloudflare in this case) - resulting in a secure transport. The SSL ciphers listed are more safe and secure than the defaults and aid performance, which will help secure the communication between Cloudflare and your server. The dhparam setting will need an additional command to get working, but essentially it allows nginx to use pre-calculated field primes and generator values to reduce resource heavy calculations on your host. You will need to make an includes folder sudo mkdir /etc/nginx/includes then run this command to generate dhparams sudo openssl dhparam -out /etc/nginx/includes/dhparam.pem 4096 Then add this conf file: sudo nano /etc/nginx/includes/common_opts.conf resolver 1.1.1.1 1.0.0.1 valid=300s; resolver_timeout 10s; gzip on; gzip_vary on; gzip_min_length 1000; gzip_proxied any; gzip_comp_level 6; gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml; gzip_disable &quot;MSIE [1-6]\\.&quot;; ssl_prefer_server_ciphers on; ssl_protocols TLSv1.2 TLSv1.3; ssl_ciphers &#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS&#39;; # use a dhparam ssl_dhparam /etc/nginx/includes/dhparam.pem; Here’s our base configuration file, make sure we import the conf file from the includes folder above. sudo nano /etc/nginx/conf.d/test.conf server { # SSL configuration listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; include /etc/nginx/includes/common_opts.conf; server_name testing.jfx.ac; location / { root /var/www/test index index.html; } } As you can see the config has no HTTP support, this is because Cloudflare can do automatic HTTPS rewrites, so why bother. Feel free to add this block in if you wish to have this functionality though. server { listen 80; listen [::]:80; server_name testing.jfx.ac; return 302 https://$server_name$request_uri; } Here is a friendly Hello World for HTML so we know it’s working :) nano /var/www/test/index.html &lt;html&gt; Hello World! &lt;/html&gt; And this will display our testing page when we go to our site, yay! Step 4 - Securing your hosts so only Cloudflare can access them Why As for why this is important, we can see that it appears the site is only serving the data if the user is going to the correct domain https://testing.jfx.ac - no way the origin can be exposed right? This is wrong. With a simple curl command it is easy to bypass the load balancer by spoofing our Host header. jfx@PC:~$ curl --insecure --header &#39;Host: testing.jfx.ac&#39; &#39;https://167.172.213.53/&#39; &lt;html&gt; Hello World! &lt;/html&gt; Scary stuff, what if someone was going through IP ranges and found our origin server this way? There’s actually a few ways to stop this, but the easiest way to stop this is to implement Authenticated Origin Pulls! More information is here from Cloudflare themselves. You can also block all HTTP/HTTPS traffic to your box unless it’s from Cloudflare using a firewall (such as UFW), this step is also explained but there are pros and cons for this which are listed below. Method Pros Cons Authenticated Origin Pulls Easier to setupCan use nginx for non Cloudflare hosts If your site is only using Cloudflare you just have an exposed web server with no purpose Firewall Blocking SafestBulletproof, no way for anyone except Cloudflare to access your web server Requires a firewall (like ufw) and a cronjob, slightly complicated setupFor Cloudflare only. Firewall will drop requests to nginx unless they are from Cloudflare 4.1 - Adding Authenticated Origin Pulls (easy) Firstly, make sure this feature is enabled on Cloudflare or the following steps will break your site. To enable it, go to Cloudflare and go to SSL/TLS -&gt; Origin Server -&gt; ON for Authenticated Origin Pulls: Next to setup Authenticated Origin Pulls on nginx, go here and at the bottom of the page download the origin-pull-ca.pem file. Once downloaded, copy its contents and output it to /etc/ssl/certs/cloudflare-origin.pem sudo nano /etc/ssl/certs/cloudflare-origin.pem *contents of origin-pull-ca.pem* Once that’s done, go back to your nginx config and add this to your SSL server block. sudo nano /etc/nginx/conf.d/test.conf ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; It should look like this server { # SSL configuration listen 443 ssl http2; listen [::]:443 ssl http2; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; include /etc/nginx/includes/common_opts.conf; server_name testing.jfx.ac; location / { root /var/www/test index index.html; } } A note: you do not need to use Cloudflare’s generated SSL certificates if you wish to use Authenticated Origin Pulls. Don’t forget to run sudo nginx -t and sudo systemctl restart nginx to reload your config! If we go to our website, we won’t notice a difference, but let’s try this curl spoof again: jfx@PC:~$ curl --insecure --header &#39;Host: testing.jfx.ac&#39; &#39;https://167.172.213.53/&#39; &lt;html&gt; &lt;head&gt;&lt;title&gt;400 No required SSL certificate was sent&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt; &lt;center&gt;No required SSL certificate was sent&lt;/center&gt; &lt;hr&gt;&lt;center&gt;nginx/1.19.1&lt;/center&gt; &lt;/body&gt; &lt;/html&gt; Mad stuff, now we have protected our site from people trying to grab our origin IP address! There is a catch though, a 400 will return on any page where something is trying to spoof, but a 403 will return on the IP without a Host header. This gives away the fact that we are trying to be safe and only accept Cloudflare’s requests. A solution to this problem is simply adding the ssl_client_certificate and ssl_verify_client from above also to default.conf. With these, the error being returned will be consistent with that as the one shown above. To do this, edit default.conf and add those two lines in so it looks like this: sudo nano /etc/nginx/conf.d/default.conf server { listen 80 default_server; listen [::]:80 default_server; server_name _; return 403; } server { # SSL configuration listen 443 ssl http2 default_server; listen [::]:443 ssl http2 default_server; ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem; ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem; ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem; ssl_verify_client on; server_name _; return 403; } With this there will be no way to determine whether or not the web server is trying to hide itself with a client certificate under a specific host. 4.2 - Blocking all HTTP/HTTPS traffic except for Cloudflare (safest) It is possible using iptables or ufw to block all web traffic coming to your server unless it’s from Cloudflare. Personally I think for a production environment this is the most safe and most bulletproof approach, as if you expect all your web traffic to come out of Cloudflare - there’s no benefit from having a public facing web server. From a security standpoint this is also the most effective. Whilst also enforcing the technique above (Authenticated Origin Pulls) you can add more security if you’re paranoid like me. The issue with this if you wish to have a host not go through Cloudflare, then this will not be possible (unless you whitelist visitors IPs). How to I have a handy script located here which will grab Cloudflare’s IP range list and output a file for use with the Real IPs nginx module. This script can also optionally add UFW rules for allowing Cloudflare IPs for https and http. If your UFW is set to block all incoming, then this will only allow incoming requests on ports 80 and 443 to Cloudflare IPs. I’m not going to write up how to setup UFW, there’s a nice DigitalOcean tutorial here. Just a word of caution: make sure you’ve disabled any existing HTTP/HTTPS rules before relying on this script. In the scripts README it tells you how to run it as a cron job so you stay on top of any updates to the Cloudflare IP range. Make sure you run the script as root and edit the UFW_RULES=false line to UFW_RULES=true Discussion I’m going to break the discussion into two sections: Common issues you may have with a Cloudflare setup and how to resolve them Even tougher security methods than shown above (but are worth looking at!) Common issues nginx not displaying Real IPs for any visitor! I have a handy script located here which will grab Cloudflare’s IP range list and output a file for use with the Real IPs nginx module. This is also the same script used in the traffic blocking section of the security section below, so if you wish to do both read on! To install the README does a good job of explaining, but essentially if you run this script it will start working like magic! You will need to automate this script (crontab recommended) to keep track of the Cloudflare IP range. A guide on how to is in the README for the script. Security Cloudflare Security Settings Not related to nginx specifically (hence why it’s down here), but these are settings which are good to have on for your website in Cloudflare. Go to SSL/TLS-&gt;Edge Certificates to enable them: Feel free to turn HSTS on for subdomains, I have it off since I do testing stuff on some of my subdomains, but it’s good practice to have on! Disabling security tokens You should be disabling security tokens on your nginx configuration which stops your nginx version being published on your website (typically shown on error pages). To do so go to your nginx.conf file which should be located at /etc/nginx/nginx.conf and add this line in the http block. sudo nano /etc/nginx/nginx.conf http { server_tokens off; ... ... } After restarting nginx sudo nginx -t and sudo systemctl restart nginx any “bad” page or 404 error, etc, should now look like this: Blocking any ports you reverse proxy from being public This one goes without saying, and while this guide doesn’t aim to be a reverse proxy how-to - it’s worth mentioning. If you reverse proxy a service through nginx, you most definitely should block it’s traffic (the port your reverse proxying through nginx) using a firewall such as UFW. I’m not going to write a guide on how-to do all this, but check out the DigitalOcean tutorial here on how to get started with ufw. Just make sure your web server is accessible when you enable ufw, which is mentioned how to do in the article. End This is my first blog post so I don’t know how well this will be received, but hopefully this helps someone setting up nginx and wanting to be security conscious.","url":"https://blog.jfx.ac/securing-nginx-origin-with-cloudflare.html","@type":"BlogPosting","headline":"How to secure your nginx + Cloudflare configuration to stop any origin leaks","dateModified":"2020-08-03T04:42:00+00:00","datePublished":"2020-08-03T04:42:00+00:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.jfx.ac/securing-nginx-origin-with-cloudflare.html"},"author":{"@type":"Person","name":"Thomas"},"@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/css/style.css"><link type="application/atom+xml" rel="alternate" href="https://blog.jfx.ac/feed.xml" title="jfx Blog" />
</head>
<body><header class="site-header">

  <div class="wrapper"><a class="site-title" rel="author" href="/">jfx Blog</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">How to secure your nginx + Cloudflare configuration to stop any origin leaks</h1>
    <p class="post-meta"><time class="dt-published" datetime="2020-08-03T04:42:00+00:00" itemprop="datePublished">
        Aug 3, 2020
      </time>~<time class="dt-modified" datetime="2020-12-28T16:26:00+00:00" itemprop="dateModified">
          Dec 28, 2020
        </time>• 
          <span itemprop="author" itemscope itemtype="http://schema.org/Person">
            <span class="p-author h-card" itemprop="name">Thomas</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I decided to write this as although a lot of guides on the internet provide a solid configuration for an nginx server, most of these guides will result in an IP leak somewhere under their configuration for the origin server somewhere.</p>

<p>So you got your nginx server setup (hopefully) and it’s serving your files (or being an effective reverse proxy), but maybe you’ve noticed loading static content (images, media, etc) load slowly… or maybe you realised that anyone can get the IP address of your website and therefore the box which is hosting it, and that creeps you out a bit. Or maybe your website doesn’t have that padlock everyone else’s has and it’s “not secure”. Luckily all these issues can be solved by Cloudflare! Or maybe your website is going through Cloudflare but sometimes you notice your origin server is still publicly displaying the website, and you want to stop this leak.</p>

<p>Unfortunately setting up Cloudflare for your website may seem simple, but setting it up securely and correctly to the inexperienced can be a difficult task. Although you may think your website is not leaking your origin IP address, it’s certainly possible that it is. This article will demonstrate how to secure your website through Cloudflare, and provide sample configurations to a hybrid nginx server which can be secure whether some vhosts are utilising Cloudflare and others aren’t (non-Cloudflare).</p>

<p>This is not a complete guide on how to setup nginx for speed or anything like that, please just rely on this for securing your vhosts and origin server.</p>

<p><strong>This guide assumes you’re using the mainline version of nginx which will mean your sites are located in <code class="language-plaintext highlighter-rouge">/etc/nginx/conf.d/</code> and your nginx user is <code class="language-plaintext highlighter-rouge">nginx</code></strong>. To install the mainline version of nginx <a href="https://www.nginx.com/blog/nginx-1-6-1-7-released/">which is recommended by the nginx team</a> follow <a href="https://www.techrepublic.com/article/how-to-install-the-latest-version-of-nginx-on-ubuntu-server-18-04/">this guide here</a> - just remember <strong>this guide will not work with any version of Ubuntu except for 18.04 UNLESS</strong> you set the release name from <code class="language-plaintext highlighter-rouge">bionic</code> to your release name which you can find on Google. Maybe I’ll write my own guide :)</p>

<h2 id="guide">Guide</h2>

<h1 id="step-1---generating-a-self-signed-ssl-certificate-for-your-default-server">Step 1 - Generating a self-signed SSL certificate for your default server</h1>

<h3 id="why-this-is-necessary">Why this is necessary</h3>

<p>This is a step that many guides on the internet do not do and instead they ask you to get a Cloudflare Origin TLS certificate for all your sites. While this is good practice because you can use Full (Strict) mode for your SSL on Cloudflare, it’s not good to implement if you wish to conceal the identity of your origin server.</p>

<p>The reason why is because of this screenshot below.</p>

<p><img src="/assets/img/cloudflare-cert-leak.png" alt="Cloudflare Certificate Leak" /></p>

<p>As you can see although no content is sent, the origin address of the website is exposed by the certificate being sent to the user. A simple web scraper could check the DNS of the certificate and easily expose the origin servers IP address.</p>

<p><em>This is a Cloudflare and nginx website I setup where the default_server block will send a Cloudflare Origin TLS Certificate and required Authenticated Origin Pulls. Don’t worry if you don’t have these setup, these are the next steps in the guide (Authenticated Origin Pulls). For reference this was following the DigitalOcean nginx+Cloudflare guide</em></p>

<h3 id="generating-your-certificate">Generating your certificate</h3>

<p>Well that’s out of the way, here’s how to generate it. You will need to make sure you have openssl installed on your system.</p>

<p>This will generate a public and private certificate that will last for 15 years. Feel free to extend it.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo openssl req -x509 -nodes -days 5475 -newkey rsa:2048 -keyout /etc/ssl/private/nginx-selfsigned.pem -out /etc/ssl/certs/nginx-selfsigned.pem
</code></pre></div></div>

<p>It will ask you for some values, just keep them as the default and maybe change your country name if desired. We will use this later in our nginx setup.</p>

<h1 id="step-2---adding-the-self-signed-certificate-to-nginx">Step 2 - Adding the Self Signed Certificate to nginx</h1>

<p><strong>For this guide I’m assuming your nginx configurations are stored in /etc/nginx/conf.d/ mainline branch, otherwise you can follow along with /etc/nginx/sites-available/</strong></p>

<p>Nginx will give us a default server file which will give you the following output once viewing your website:</p>

<p>This file (default.conf) can be rewritten to default.old (if in conf.d) - or removed from your sites-enabled folder, and should be replaced with this new file:</p>

<p><strong>sudo nano /etc/nginx/conf.d/default.conf</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name _;
	return 403;
}

server {
	# SSL configuration
	listen 443 ssl http2 default_server;
	listen [::]:443 ssl http2 default_server;
	ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem;
	ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem;
	server_name _;
	return 403;
}
</code></pre></div></div>

<p>Then type <code class="language-plaintext highlighter-rouge">sudo nginx -t</code> to make sure your configuration is correct before typing <code class="language-plaintext highlighter-rouge">sudo systemctl restart nginx</code> to restart nginx to respond to the configuration change.</p>

<p>This provides us with a base setup. If a request comes to the origin server and it does not have a server block it will come back as 403. Try test it out by going to the IP address of your box on http:// and https://</p>

<p><img src="/assets/img/403-shown.png" alt="403 Shown" /></p>

<h1 id="step-3---configuring-a-host">Step 3 - Configuring a host</h1>

<p>After this we can actually configure a host we would like to route properly through Cloudflare and nginx (yay)! aka something that isn’t our default_server.
For the sake of this tutorial I’ve made a <code class="language-plaintext highlighter-rouge">/var/www/</code> folder and have my nginx pointed to <code class="language-plaintext highlighter-rouge">/var/www/test/</code> - the config is below.
If you want to follow along, make sure you run these commands.</p>

<h3 id="31---making-a-test-host-skippable-if-you-have-content-already">3.1 - Making a test host (skippable if you have content already)</h3>

<p>This little micro step is skippable if you have a host working already serving content. If you wish to <a href="#32---host-config">skip click here to 3.2.</a></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mkdir -p /var/www/test/
sudo chown -R nginx:nginx /var/www/
sudo find /var/www -type f -exec chmod 664 {} \;
sudo find /var/www -type d -exec chmod 775 {} \;
sudo find /var/www -type d -exec chmod g+s {} \;
</code></pre></div></div>

<p>I actually copied most of these perms from <a href="https://gist.github.com/stefanbc/9956ed211cd32571e73f">this guide</a>.
Essentially:</p>

<ul>
  <li>changes the owner of /var/www to nginx and anyone in the nginx group.</li>
  <li>adds 644 permissions (-rw-rw-r–) to all files in /var/www.</li>
  <li>adds 775 permissions (drwxrwxr-x) to all directories in /var/www.</li>
  <li>sets the SGID bit on /var/www and all directories therein; This means that all new files and subdirectories created within the current directory inherit the group ID of the directory, rather than the primary group ID of the user who created the file. This will also be passed on to new subdirectories created in the current directory.</li>
</ul>

<p><strong>Reminder if your nginx user is www-data the chown command should have www-data:www-data instead of nginx:nginx</strong></p>

<p>Make sure your user is in the nginx (or www-data) group, by typing <code class="language-plaintext highlighter-rouge">groups USERNAME</code>. If you cannot see the group listed, run:</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo usermod -aG nginx USERNAME
</code></pre></div></div>

<p>and restart your shell.</p>

<p>This will make the required folders and give nginx ownership of them. Essentially we are setting up our /var/www/ environment to be able to serve a website.</p>

<h3 id="32---host-config">3.2 - Host Config</h3>

<p>Below is a sample of a nginx config that will simply display the static content of the website. If you have an existing host make sure you have any missing fields (namely the SSL certificate ones) - and the include file.</p>

<p>Below is a few optimisations we can add to nginx to increase speed but also increase its security.</p>
<ul>
  <li>Using a custom resolver <a href="1.1.1.1">Cloudflare’s DNS server</a> will result in increased speed for any DNS queries your server runs.</li>
  <li>gzip compression will mean static content will be served faster.</li>
  <li>The SSL protocols changes will ensure only <code class="language-plaintext highlighter-rouge">TLS 1.2 and TLS 1.3</code> are used between your site and your visitors (Cloudflare in this case) - resulting in a secure transport.</li>
  <li>The SSL ciphers listed are more safe and secure than the defaults and aid performance, which will help secure the communication between Cloudflare and your server.</li>
  <li>The dhparam setting will need an additional command to get working, but essentially it allows nginx to use pre-calculated field primes and generator values to reduce resource heavy calculations on your host.</li>
</ul>

<p>You will need to make an includes folder <code class="language-plaintext highlighter-rouge">sudo mkdir /etc/nginx/includes</code> then run this command to generate dhparams <code class="language-plaintext highlighter-rouge">sudo openssl dhparam -out /etc/nginx/includes/dhparam.pem 4096</code></p>

<p>Then add this conf file:</p>

<p><strong>sudo nano /etc/nginx/includes/common_opts.conf</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resolver 1.1.1.1 1.0.0.1 valid=300s;
resolver_timeout 10s;
gzip on;
gzip_vary on;
gzip_min_length 1000;
gzip_proxied any;
gzip_comp_level 6;
gzip_types text/plain text/css text/xml application/xml text/javascript application/x-javascript image/svg+xml;
gzip_disable "MSIE [1-6]\.";
ssl_prefer_server_ciphers on;
ssl_protocols TLSv1.2 TLSv1.3;
ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';
# use a dhparam
ssl_dhparam /etc/nginx/includes/dhparam.pem;
</code></pre></div></div>

<p>Here’s our base configuration file, make sure we import the conf file from the includes folder above.</p>

<p><strong>sudo nano /etc/nginx/conf.d/test.conf</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
	# SSL configuration
	listen 443 ssl http2;
	listen [::]:443 ssl http2;
	ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem;
	ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem;
	include /etc/nginx/includes/common_opts.conf;
	server_name testing.jfx.ac;

	location /  {
		root /var/www/test
		index index.html;
	}
}
</code></pre></div></div>

<p>As you can see the config has no HTTP support, this is because Cloudflare can do automatic HTTPS rewrites, so why bother. Feel free to add this block in if you wish to have this functionality though.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
	listen 80;
	listen [::]:80;

	server_name testing.jfx.ac;
	return 302 https://$server_name$request_uri;
}
</code></pre></div></div>

<p>Here is a friendly Hello World for HTML so we know it’s working :)</p>

<p><strong>nano /var/www/test/index.html</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;html&gt;
Hello World!
&lt;/html&gt;
</code></pre></div></div>

<p>And this will display our testing page when we go to our site, yay!</p>

<h1 id="step-4---securing-your-hosts-so-only-cloudflare-can-access-them">Step 4 - Securing your hosts so only Cloudflare can access them</h1>

<h3 id="why">Why</h3>

<p>As for why this is important, we can see that it appears the site is only serving the data if the user is going to the correct domain <code class="language-plaintext highlighter-rouge">https://testing.jfx.ac</code> - no way the origin can be exposed right? This is wrong. With a simple curl command it is easy to bypass the load balancer by spoofing our <code class="language-plaintext highlighter-rouge">Host</code> header.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jfx@PC:~$ curl --insecure --header 'Host: testing.jfx.ac' 'https://167.172.213.53/'
&lt;html&gt;
Hello World!
&lt;/html&gt;
</code></pre></div></div>

<p>Scary stuff, what if someone was going through IP ranges and found our origin server this way? There’s actually a few ways to stop this, but the easiest way to stop this is to implement Authenticated Origin Pulls! More information is <a href="https://blog.cloudflare.com/protecting-the-origin-with-tls-authenticated-origin-pulls">here from Cloudflare themselves</a>. You can also block all HTTP/HTTPS traffic to your box unless it’s from Cloudflare using a firewall (such as UFW), this step is also explained but there are pros and cons for this which are listed below.</p>

<table>
  <thead>
    <tr>
      <th>Method</th>
      <th style="text-align: left">Pros</th>
      <th>Cons</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><a href="#41---adding-authenticated-origin-pulls-easy">Authenticated Origin Pulls</a></td>
      <td style="text-align: left"><ul><li>Easier to setup</li><li>Can use nginx for non Cloudflare hosts</li></ul></td>
      <td><ul><li>If your site is only using Cloudflare you just have an exposed web server with no purpose</li></ul></td>
    </tr>
    <tr>
      <td><a href="#42---blocking-all-httphttps-traffic-except-for-cloudflare-safest">Firewall Blocking</a></td>
      <td style="text-align: left"><ul><li>Safest</li><li>Bulletproof, no way for anyone except Cloudflare to access your web server</li></ul></td>
      <td><ul><li>Requires a firewall (like ufw) and a cronjob, slightly complicated setup</li><li>For Cloudflare only. Firewall will drop requests to nginx unless they are from Cloudflare</li></ul></td>
    </tr>
  </tbody>
</table>

<h3 id="41---adding-authenticated-origin-pulls-easy">4.1 - Adding Authenticated Origin Pulls (easy)</h3>

<p>Firstly, make sure this feature is enabled on Cloudflare or the following steps will break your site. To enable it, go to Cloudflare and go to <strong>SSL/TLS -&gt; Origin Server -&gt; ON for Authenticated Origin Pulls</strong>:</p>

<p><img src="/assets/img/authenticated-origin-pulls-on.png" alt="Cloudflare Authenticated Origin Pulls On" /></p>

<p>Next to setup Authenticated Origin Pulls on nginx, <a href="https://support.cloudflare.com/hc/en-us/articles/204899617">go here</a> and at the bottom of the page download the <code class="language-plaintext highlighter-rouge">origin-pull-ca.pem</code> file. Once downloaded, copy its contents and output it to <code class="language-plaintext highlighter-rouge">/etc/ssl/certs/cloudflare-origin.pem</code></p>

<p><strong>sudo nano /etc/ssl/certs/cloudflare-origin.pem</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>*contents of origin-pull-ca.pem*
</code></pre></div></div>

<p>Once that’s done, go back to your nginx config and add this to your <strong>SSL server block.</strong></p>

<p><strong>sudo nano /etc/nginx/conf.d/test.conf</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem;
ssl_verify_client on;
</code></pre></div></div>

<p>It should look like this</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
	# SSL configuration
	listen 443 ssl http2;
	listen [::]:443 ssl http2;
	ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem;
	ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem;
	ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem;
	ssl_verify_client on;
	include /etc/nginx/includes/common_opts.conf;
	server_name testing.jfx.ac;

	location /  {
		root /var/www/test
		index index.html;
	}
}
</code></pre></div></div>

<p><em>A note: you do not need to use Cloudflare’s generated SSL certificates if you wish to use Authenticated Origin Pulls.</em></p>

<p><strong>Don’t forget to run <code class="language-plaintext highlighter-rouge">sudo nginx -t</code> and <code class="language-plaintext highlighter-rouge">sudo systemctl restart nginx</code> to reload your config!</strong></p>

<p>If we go to our website, we won’t notice a difference, but let’s try this curl spoof again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jfx@PC:~$ curl --insecure --header 'Host: testing.jfx.ac' 'https://167.172.213.53/'
&lt;html&gt;
&lt;head&gt;&lt;title&gt;400 No required SSL certificate was sent&lt;/title&gt;&lt;/head&gt;
&lt;body&gt;
&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;/h1&gt;&lt;/center&gt;
&lt;center&gt;No required SSL certificate was sent&lt;/center&gt;
&lt;hr&gt;&lt;center&gt;nginx/1.19.1&lt;/center&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre></div></div>

<p>Mad stuff, now we have protected our site from people trying to grab our origin IP address!</p>

<p>There is a catch though, a 400 will return on any page where something is trying to spoof, but a 403 will return on the IP without a Host header. This gives away the fact that we are trying to be safe and only accept Cloudflare’s requests. A solution to this problem is simply adding the <code class="language-plaintext highlighter-rouge">ssl_client_certificate</code> and <code class="language-plaintext highlighter-rouge">ssl_verify_client</code> from above also to default.conf. With these, the error being returned will be consistent with that as the one shown above. To do this, edit default.conf and add those two lines in so it looks like this:</p>

<p><strong>sudo nano /etc/nginx/conf.d/default.conf</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
	listen 80 default_server;
	listen [::]:80 default_server;
	server_name _;
	return 403;
}

server {
	# SSL configuration
	listen 443 ssl http2 default_server;
	listen [::]:443 ssl http2 default_server;
	ssl_certificate /etc/ssl/certs/nginx-selfsigned.pem;
	ssl_certificate_key /etc/ssl/private/nginx-selfsigned.pem;
	ssl_client_certificate /etc/ssl/certs/cloudflare-origin.pem;
	ssl_verify_client on;
	server_name _;
	return 403;
}
</code></pre></div></div>

<p>With this there will be no way to determine whether or not the web server is trying to hide itself with a client certificate under a specific host.</p>

<h3 id="42---blocking-all-httphttps-traffic-except-for-cloudflare-safest">4.2 - Blocking all HTTP/HTTPS traffic except for Cloudflare (safest)</h3>

<p>It is possible using iptables or ufw to block all web traffic coming to your server unless it’s from Cloudflare. Personally I think for a production environment this is the most safe and most bulletproof approach, as if you expect all your web traffic to come out of Cloudflare - there’s no benefit from having a public facing web server. From a security standpoint this is also the most effective. Whilst also enforcing the technique above (Authenticated Origin Pulls) you can add more security if you’re paranoid like me.</p>

<p>The issue with this if you wish to have a host not go through Cloudflare, then this will not be possible (unless you whitelist visitors IPs).</p>

<h3 id="how-to">How to</h3>

<p>I have a <a href="https://github.com/itsjfx/cloudflare-nginx-ips">handy script located here</a> which will grab <a href="https://www.cloudflare.com/ips">Cloudflare’s IP range list</a> and output a file for use with the <a href="https://nginx.org/en/docs/http/ngx_http_realip_module.html">Real IPs nginx module</a>. This script can also optionally add UFW rules for allowing Cloudflare IPs for https and http. If your UFW is set to block all incoming, then this will only allow incoming requests on ports 80 and 443 to Cloudflare IPs. I’m not going to write up how to setup UFW, there’s a <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-20-04">nice DigitalOcean tutorial here</a>. Just a word of caution: <strong>make sure you’ve disabled any existing HTTP/HTTPS rules before relying on this script.</strong> In the scripts README it tells you how to run it as a cron job so you stay on top of any updates to the Cloudflare IP range.</p>

<p><strong>Make sure you run the script as root and edit the <code class="language-plaintext highlighter-rouge">UFW_RULES=false</code> line to <code class="language-plaintext highlighter-rouge">UFW_RULES=true</code></strong></p>

<p><br /></p>

<h2 id="discussion">Discussion</h2>

<p>I’m going to break the discussion into two sections:</p>

<ul>
  <li>Common issues you may have with a Cloudflare setup and how to resolve them</li>
  <li>Even tougher security methods than shown above (but are worth looking at!)</li>
</ul>

<h1 id="common-issues">Common issues</h1>

<h3 id="nginx-not-displaying-real-ips-for-any-visitor">nginx not displaying Real IPs for any visitor!</h3>

<p>I have a <a href="https://github.com/itsjfx/cloudflare-nginx-ips">handy script located here</a> which will grab <a href="https://www.cloudflare.com/ips">Cloudflare’s IP range list</a> and output a file for use with the <a href="https://nginx.org/en/docs/http/ngx_http_realip_module.html">Real IPs nginx module</a>. This is also the same script used in the traffic blocking section of the security section below, so if you wish to do both read on!</p>

<p>To install the README does a good job of explaining, but essentially if you run this script it will start working like magic! You will need to automate this script (crontab recommended) to keep track of the Cloudflare IP range. A guide on how to is in the README for the script.</p>

<h1 id="security">Security</h1>

<h3 id="cloudflare-security-settings">Cloudflare Security Settings</h3>

<p>Not related to nginx specifically (hence why it’s down here), but these are settings which are good to have on for your website in Cloudflare. Go to <strong>SSL/TLS-&gt;Edge Certificates</strong> to enable them:</p>

<p><img src="/assets/img/cloudflare-ssl-settings-1.png" alt="Cloudflare SSL Settings 1" />
<img src="/assets/img/cloudflare-ssl-settings-2.png" alt="Cloudflare SSL Settings 2" /></p>

<p>Feel free to <strong>turn HSTS on for subdomains</strong>, I have it off since I do testing stuff on some of my subdomains, but it’s <strong>good practice to have on!</strong></p>

<h3 id="disabling-security-tokens">Disabling security tokens</h3>

<p>You should be disabling security tokens on your nginx configuration which stops your nginx version being published on your website (typically shown on error pages). To do so go to your <code class="language-plaintext highlighter-rouge">nginx.conf</code> file which should be located at <code class="language-plaintext highlighter-rouge">/etc/nginx/nginx.conf</code> and add this line in the <code class="language-plaintext highlighter-rouge">http</code> block.</p>

<p><strong>sudo nano /etc/nginx/nginx.conf</strong></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>http {
	server_tokens off;
	...
	...
}
</code></pre></div></div>

<p>After restarting nginx <strong>sudo nginx -t and sudo systemctl restart nginx</strong> any “bad” page or 404 error, etc, should now look like this:</p>

<p><img src="/assets/img/server-tokens-off.png" alt="server-tokens-off" /></p>

<h3 id="blocking-any-ports-you-reverse-proxy-from-being-public">Blocking any ports you reverse proxy from being public</h3>

<p>This one goes without saying, and while this guide doesn’t aim to be a reverse proxy how-to - it’s worth mentioning. If you reverse proxy a service through nginx, you most definitely should block it’s traffic (the port your reverse proxying through nginx) using a firewall such as UFW. I’m not going to write a guide on how-to do all this, but check out the <a href="https://www.digitalocean.com/community/tutorials/how-to-set-up-a-firewall-with-ufw-on-ubuntu-20-04">DigitalOcean tutorial here</a> on how to get started with ufw. Just make sure your web server is accessible when you enable ufw, which is mentioned how to do in the article.</p>

<h2 id="end">End</h2>

<p>This is my first blog post so I don’t know how well this will be received, but hopefully this helps someone setting up nginx and wanting to be security conscious.</p>

  </div><a class="u-url" href="/securing-nginx-origin-with-cloudflare.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <div class="footer-col-wrapper">
      <div class="footer-col">
        <p class="feed-subscribe">
          <a href="/feed.xml">
            <svg class="svg-icon orange">
              <use xlink:href="/assets/minima-social-icons.svg#rss"></use>
            </svg><span>Subscribe</span>
          </a>
        </p>
        <ul class="contact-list">
          <li class="p-name">Thomas (jfx)</li>
          <li><a class="u-email" href="mailto:me@jfx.ac">me@jfx.ac</a></li>
        </ul>
      </div>
      <div class="footer-col">
        <p>A blog dedicated to my rambling thoughts about tech and privacy.</p>
      </div>
    </div>

    <div class="social-links"><ul class="social-media-list"><li><a rel="me" href="https://github.com/itsjfx" title="itsjfx"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg></a></li><li><a rel="me" href="https://twitter.com/itsjfx" title="itsjfx"><svg class="svg-icon grey"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg></a></li></ul>
</div>

  </div>

</footer>
</body>

</html>
